/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 2);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export FormatterBuilder */


/** @typedef {Object} FormatterBuilder~Options
* @description FormatterBuilder options
* @property {Object=} attributes
* @property {Object=} styles
* @property {Object=} events
*/

/** Dictionary that contain reserved attribute to context element
* @type {object}
* @private
*/
var _reservedAttributesDict = {
	"api": true,
	"wrapper": true,
	"grid": true,
	"field": true,
	"rowIndex": true,
	"value": true,
	"setData": true,
	"getData": true,
	"styles": true,
	"attributes": true,
	"tagName": true,
	"events": true,
	"userEvents": true,
	"defaultEvents": true,
	"onContextCreated": true,
	"onElementCreated": true,
	"onElementUpdated": true,
	"changeHook": true,
	"changeHooks": true
};

function convertPxToString(px) {
	return px + (typeof px === "number" ? "px" : "");
}

function positionLocator(ctx, userFunc, e) { // eslint-disable-line
	if (!ctx.grid.isBinding()) {
		ctx.grid.getRelativePosition(e, ctx);
		userFunc(e, ctx);
	}
}

function forEachSetProperties(attrs, fn) {
	if (typeof attrs === "object" && typeof fn === "function") {
		for (var name in attrs) {
			var val = attrs[name];
			if (name === "height" || name === "width") {
				val = convertPxToString(val);
			} else {
				val += ""; // force to string
			}
			fn(name, val);
		}
	}
}

function assignAttribute(text, options, defaultOpt) {
	forEachSetProperties(defaultOpt.attributes, function (name, val) {
		text.push('    element.setAttribute("' + name + '", "' + val + '");');
	});

	forEachSetProperties(options.attributes, function (name, val) {
		text.push('    element.setAttribute("' + name + '", "' + val + '");');
	});
}

function assignStyle(text, options, defaultOpt) {
	forEachSetProperties(defaultOpt.styles, function (name, val) {
		text.push('    element.style["' + name + '"] = "' + val + '";');
	});

	forEachSetProperties(options.styles, function (name, val) {
		text.push('    element.style["' + name + '"] = "' + val + '";');
	});
}

function assignListener(text, options, defaultOpt) {
	var name;
	var events = defaultOpt.events || {};
	for (name in events) {
		if (typeof events[name] === "function") {
			text.push('    element.addEventListener("' + name + '", positionLocator.bind(null, ctx, ctx.defaultEvents["' + name + '"]));');
		}
	}

	events = options.events || {};
	for (name in events) {
		if (typeof events[name] === "function") {
			text.push('    element.addEventListener("' + name + '", positionLocator.bind(null, ctx, ctx.userEvents["' + name + '"]));');
		}
	}
}


/** @private
* @this ContextObject
* @param {Object} colDef User's column definition object
* @param {tr.Grid} grid Core grid instance
*/
function _onInitContextObject(colDef, grid) { // Executed once per column
	this.grid = grid; // WARNING: using ctx as closure variable
	if (!this.field) {
		this.field = colDef.field;
		if(this.disablingField === null) {
			this.disablingField = this.field ? this.field + "_DISABLED" : null;
		}
		if(this.errorField === null) {
			this.errorField = this.field ? this.field + "_ERROR" : null;
		}
	}

	this.setData = _setData;
	this.getData = _getData;
	this.disableElement = _disableElement;
	this.isElementDisabled = _isElementDisabled;
	this.setError = _setError;
	this.getError = _getError;
}
/** @private
* @this ContextObject
* @param {string} field
* @param {*} value
*/
function _setData(field, value) {
	if(this.wrapper === "real-time-grid") {
		var rowDef = this.api.getRowDefinition(this.rowIndex);
		if(rowDef) {
			rowDef.setStaticData(field, value);
		}
	} else {
		this.api.getDataView().setDataAt(this.rowIndex, field, value); // WARNING: Use of closure variable
	}
}
/** @private
* @this ContextObject
* @param {boolean} field
* @return {*} Value
*/
function _getData(field) {
	if(this.wrapper === "real-time-grid") {
		var rowDef = this.api.getRowDefinition(this.rowIndex);
		return rowDef ? rowDef.getData(field) : null;
	} else {
		return this.api.getDataView().getDataAt(this.rowIndex, field);
	}
}
/** @private
* @this ContextObject
* @param {boolean} bool
*/
function _disableElement(bool) {
	if(this.disablingField) {
		this.setData(this.disablingField, bool !== false);
	}
}
/** @private
* @this ContextObject
* @return {boolean}
*/
function _isElementDisabled() {
	return this.getData(this.disablingField);
}
/** @private
* @this ContextObject
* @param {*} val
*/
function _setError(val) {
	if(this.errorField) {
		this.setData(this.errorField, val);
	}
}
/** @private
* @this ContextObject
* @return {*}
*/
function _getError() {
	return this.getData(this.errorField);
}


function buildFnText(wrapper, ctx, options, defaultOpt) {
	for (var defKey in defaultOpt) {
		if (!_reservedAttributesDict[defKey]) {
			ctx[defKey] = defaultOpt[defKey];
		}
	}
	for (var optKey in options) {
		if (!_reservedAttributesDict[optKey]) {
			ctx[optKey] = options[optKey];
		}
	}

	if (defaultOpt.onContextCreated) {
		defaultOpt.onContextCreated(ctx, options);
	}

	var text = [];
	// Initial setup based on different types of grid
	if(wrapper === "real-time-grid") {
		text.push('(function(e) {');
		text.push('  ctx.api = e["grid"];');
		text.push('  ctx.wrapper = "real-time-grid";');
		if (options.field) {
			text.push('  ctx.value = e["rowData"][ctx.field];');
		} else {
			text.push('  ctx.value = e["data"];');
		}
		text.push('  ctx.rowIndex = e["rowIndex"];');
		text.push('  ctx.colIndex = e["colIndex"];');
		text.push('  var cell = ctx.cell = e["cell"];'); // cell is for referencing later
	} else {
		text.push('(function(rowIndex, columnIndex, value, cell, colDef, dataRow, dataTable, dataView, cgrid) {');
		text.push('  ctx.api = cgrid;');
		text.push('  ctx.wrapper = "composite-grid";');
		if (options.field) {
			text.push('  ctx.value = dataRow ? dataRow[ctx.field] : null;');
		} else {
			text.push('  ctx.value = value;');
		}
		text.push('  ctx.rowIndex = rowIndex;');
		text.push('  ctx.colIndex = columnIndex;');
		text.push('  ctx.cell = cell;');
	}

	// Common setups triggered once per element
	text.push('  var element = cell.getContent();');
	text.push('  if(!element || (element._formatterName !== "' + defaultOpt.refName + '")) {');
	text.push('    element = document.createElement("' + defaultOpt.tagName + '");');
	text.push('    element._formatterName = "' + defaultOpt.refName + '";');
	if (defaultOpt.onElementCreated) {
		ctx.onElementCreated = defaultOpt.onElementCreated;
		text.push('    ctx.onElementCreated(element, ctx);');
	}

	assignAttribute(text, options, defaultOpt);
	assignStyle(text, options, defaultOpt);
	assignListener(text, options, defaultOpt);

	text.push('  }\n'); // End of setup

	if(typeof options.disablingField  === "string" || options.disablingField == null) {
		text.push('  if(ctx.isElementDisabled()) {');
		text.push('    element.setAttribute("disabled", "");');
		text.push('  } else {');
		text.push('    element.removeAttribute("disabled");');
		text.push('  }');
	}
	if(typeof options.errorField  === "string" || options.errorField == null) {
		text.push('  if(ctx.getError()) {');
		text.push('    element.setAttribute("error", "");');
		text.push('  } else {');
		text.push('    element.removeAttribute("error");');
		text.push('  }');
	}

	// Element binding/updating
	if (defaultOpt.onElementUpdated) {
		ctx.onElementUpdated = defaultOpt.onElementUpdated;
		text.push('  ctx.onElementUpdated(element, ctx);');
	}

	if (typeof options.onElementRendered === "function") {
		ctx.onElementRendered = options.onElementRendered;
		text.push('  ctx.onElementRendered(element, ctx);');
	}

	text.push('  cell.setContent(element);');
	text.push('})');
	return text.filter(Boolean).join('\n');
}

/** @constructor
* @param {*=} options
*/
var FormatterBuilder = function (options) {
	// TODO: FormatterBuilder should not be initializable
};

/** @public
* @param {FormatterBuilder~Options=} userOptions
* @param {FormatterBuilder~Options=} defaultOpt
* @return {Object}
*/
FormatterBuilder.create = function (userOptions, defaultOpt) {
	userOptions = userOptions || {};
	defaultOpt = defaultOpt || {};
	var ctx = {}; // WANRING: This object is used as a closure variable
	ctx.field = userOptions.field;

	if (defaultOpt.changeHook) {
		var changeHandler = userOptions.changeHandler || defaultOpt.changeHandler;
		if (!defaultOpt.events) {
			defaultOpt.events = {};
		}
		defaultOpt.events[defaultOpt.changeHook] = changeHandler;
	} else if (defaultOpt.changeHooks) {
		var changeHandlers = userOptions.changeHandlers || defaultOpt.changeHandlers;
		if (!defaultOpt.events) {
			defaultOpt.events = {};
		}
		for (var i = 0; i < changeHandlers.length; i++) {
			defaultOpt.events[defaultOpt.changeHooks[i]] = changeHandlers[i];
		}
	}

	if (defaultOpt.events) {
		ctx.defaultEvents = defaultOpt.events;
	}

	if (userOptions.events) {
		ctx.userEvents = userOptions.events;
	}

	var txt;
	txt = buildFnText("composite-grid", ctx, userOptions, defaultOpt);
	var compositeGridBinding = eval(txt);

	txt = buildFnText("real-time-grid", ctx, userOptions, defaultOpt);
	var rtGridBinding = eval(txt);

	return {
		render: function () {},
		init: _onInitContextObject.bind(ctx),
		bind: compositeGridBinding,
		binding: rtGridBinding
	};
};

/* harmony default export */ __webpack_exports__["a"] = (FormatterBuilder);



/***/ }),
/* 1 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export Util */
/* unused harmony export extendObject */
/* unused harmony export cloneObject */
/* unused harmony export arrayToObject */
/* unused harmony export extendProperty */
/* unused harmony export extendArrayProperty */
/* unused harmony export parseCondition */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return prettifyCss; });
/* unused harmony export getShadowRoot */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return injectCss; });
/* unused harmony export isIE */
/* unused harmony export isMac */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return nestedObjectToArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return rgb2Hex; });
/* unused harmony export prepareTSVContent */
/** @namespace */
var Util = {};

/** This is a shorthand for fetch() API by POST method and with json body <br>
* WARNING: fetch is not supported in IE (including IE11)
* @public
* @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch}
* @function
* @param {string} url
* @param {Object|string} obj
* @return {!Promise<Response>}
*/
Util.post = function(url, obj) { // Not supported in IE
	return Util._post(url, obj).then(Util.toJSON);
};
/** Request a server response from server as text by POST method <br>
* WARNING: fetch is not supported in IE (including IE11)
* @public
* @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch}
* @function
* @param {string} url
* @param {Object|string} obj
* @return {!Promise<Response>}
*/
Util.requestText = function(url, obj) { // Not supported in IE
	return Util._post(url, obj, "text/plain").then(Util.toText);
};
/** Request a server response from server by POST method and with url-encoded body <br>
* WARNING: fetch is not supported in IE (including IE11)
* @public
* @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch}
* @function
* @param {string} url
* @param {string} obj
* @return {!Promise<Response>}
*/
Util.requestByUrlEncoded = function(url, obj) { // Not supported in IE
	return Util._post(url, obj, "application/x-www-form-urlencoded").then(Util.toJSON);
};

/** @public
* @function
* @param {Response} resp
* @return {!Promise<Object>}
*/
Util.toJSON = function (resp) {
	if(Util._logError(resp)) {
		return Promise.reject(resp);
	}
	return resp.json();
};
/** @public
* @function
* @param {Response} resp
* @return {!Promise<string>}
*/
Util.toText = function (resp) {
	if(Util._logError(resp)) {
		return Promise.reject(resp);
	}
	return resp.text();
};

/** @private
* @see {@link https://en.wikipedia.org/wiki/List_of_HTTP_status_codes}
* @function
* @param {Response} resp
* @return {boolean}
*/
Util._logError = function(resp) {
	if(resp && resp.status >= 300) {
		console.log("Response " + resp.status + ": " + resp.statusText);
		return true;
	}
	return false;
};
/** @private
* @function
* @param {string} url
* @param {Object|string} obj
* @param {string=} contentType
* @return {!Promise<Response>}
*/
Util._post = function(url, obj, contentType) {
	var options = {
		method: obj ? "POST" : "GET",
		headers: { "Content-Type": contentType || "application/json" }
	};
	if(obj) {
		options.body = typeof obj === "string" ? obj : JSON.stringify(obj);
	}

	return fetch(url, options);
};

/** WARNING: Only one level of property tree is affected (i.e. no recursive or nested operation). <br>
* Property with undefined or null value will not have an impact on the object. <br>
* Existing properties will be overridden.
* @public
* @function
* @param {Object} obj Object that is extended (new properties will be added to this object)
* @param {Object=} extender Master object (no modification will be made on the extender)
* @param {Array.<string>=} limiters Specify property to be extended
* @return {Object}
*/
var extendObject = function (obj, extender, limiters) {
	if(!obj) { // null undefined NaN empty string and 0
		return null;
	}
	if(!extender || obj === extender) {
		return obj;
	}

	var key;
	if(limiters) {
		var len = limiters.length;
		for(var i = 0; i < len; ++i) {
			key = limiters[i];
			if(key) {
				extendProperty(obj, extender, key);
			}
		}
	} else {
		for(key in extender) {
			extendProperty(obj, extender, key);
		}
	}
	return obj;
};
/** WARNING: Only one level of property tree is affected (i.e. no recursive or nested operation). <br>
* Property with undefined or null value will not be cloned.
* @public
* @function
* @param {Object} obj
* @param {Array.<string>=} limiters
* @return {Object}
*/
var cloneObject = function (obj, limiters) {
	return extendObject({}, obj, limiters);
};
/** @public
* @param {Array=} data
* @param {Array.<string>=} fields In case of the given data is an array, this param will be used for mapping index to field
* @return {Object|null}
*/
var arrayToObject = function(data, fields) {
	if(!Array.isArray(data)) {
		return data;
	} else if(!fields) {
		return null;
	}
	var ary = data;
	data = {};
	var len = ary.length;
	for(var i = 0; i < len; ++i) {
		var field = fields[i];
		// eslint-disable-next-line no-undefined
		if(field && ary[i] !== undefined) {
			data[field] = ary[i];
		}
	}
	return data;
};
/** Replace the specified property with the value from the extender. If the value is an array, the value will be added to the array instead of replacement
* @public
* @function
* @param {Object} obj
* @param {Object} extender
* @param {string} propName
* @example
* extendProperty({a: 0}, {a: 1}, "a"); // {a: 1}
* extendProperty({a: 0}, {b: 1}, "b"); // {a: 0, b: 1}
* extendProperty({a: [0]}, {a: 1}, "a"); // {a: [0, 1]}
* extendProperty({a: [0]}, {a: [1, 2]}, "a"); // {a: [0, 1, 2]}
*/
var extendProperty = function (obj, extender, propName) {
	var val = extender[propName];
	if(val != null) {
		var objVal = obj[propName];
		if(Array.isArray(objVal)) {
			obj[propName] = objVal.concat(val);
		} else if(Array.isArray(val) && objVal) {
			obj[propName] = val.concat(objVal); // TODO: Preserve the order
		} else {
			obj[propName] = val; // WARNING: Overriding existing data
		}
	}
};
/** Array.push() is much faster than Array.concat(). The downside is the parameters must be an array, whereas concat() has no such requirement. <br>
* This method excels in extending known array property in an object.
* @public
* @function
* @param {Object} obj
* @param {string} propName
* @param {*} ary
* @return {Array} Returns the result of the extended array
* @see {@link https://dev.to/uilicious/javascript-array-push-is-945x-faster-than-array-concat-1oki}
* @example
* var obj = {};
* extendArrayProperty(obj, "prop1", 1); // [1]
* extendArrayProperty(obj, "prop1", 2); // [1, 2]
* extendArrayProperty(obj, "prop1", [3, 4]); // [1, 2, 3, 4]
* obj.prop2 = 5;
* extendArrayProperty(obj, "prop2", 6); // [5, 6]
* extendArrayProperty(obj, "prop2", [7]); // [5, 6, 7]
* extendArrayProperty(obj, "prop2", null); // null
*/
var extendArrayProperty = function (obj, propName, ary) {
	var objAry = null;
	if(ary) {
		var objVal = obj[propName];
		if(objVal) {
			if(Array.isArray(objVal)) {
				objAry = objVal;
			} else {
				objAry = obj[propName] = [objVal];
			}
		} else {
			objAry = obj[propName] = [];
		}
		// objAry is guaranteed to be an array at this point

		if(Array.isArray(ary)) {
			if(ary.length) {
				if(ary.length > 1) {
					Array.prototype.push.apply(objAry, ary);
				} else {
					objAry.push(ary[0]);
				}
			}
		} else {
			objAry.push(ary);
		}
	}
	return objAry;
};


/** Regex for matching the field token E.g. '[CF_BID]'
* @type {!RegExp}
* @private
* @const
*/
var _bracketExp = new RegExp(/\[[^\[]*\]/g); // eslint-disable-line no-useless-escape
/** @public
* @function
* @param {string|Function} expression
* @return {Function}
* @example
* var fn = parseCondition("[CF_BID] >= 10 && [CF_BID] <= 100");
* window.console.log(fn(25));
*/
var parseCondition = function(expression) {
	if(!expression) {
		return null;
	}
	if(typeof expression !== "string") {
		return (typeof expression == "function") ? /** @type {Function} */(expression) : null;
	}

	var brackets = expression.match(_bracketExp); // Retrieving field tokens (anything in between brackets)
	var map = {}; // For checking duplication
	var fields = [];
	var len = brackets ? brackets.length : 0;
	for(var i = len; --i >= 0;) {
		var field = brackets[i];
		if(!map[field]) {
			map[field] = "f[" + fields.length + "]"; // Create mapping of field token to array with index E.g. { "[CF_BID]": "f[0]" }
			fields.push(field.substring(1, field.length - 1)); // Strip '[' and ']' of field token to get field name
		}
	}

	// Replace the field tokens with rowData of array with index E.g. [CF_BID] ==> rowData[f[0]]
	expression = expression.replace(_bracketExp, function(match) {
		return "rowData[" + map[match] + "]";
	});
	var finalExp = "(function(f, rowData) { return (" + expression + "); })";

	var fn = null;
	try {
		fn = eval(finalExp);
		fn = fn.bind(null, fields); // Bind fields for matching field name
	} catch(err) {
		console.log(err.message);
	}
	return (fn) ? fn : null;
};


/** @private
* @param {string|Array.<string>} item
* @return {string}
*/
var _encloseBracket = function(item) {
	return Array.isArray(item) ? "{\n" + item.join("\n") + "\n}" : item;
};
/** @private
* @param {string} str
* @return {string}
*/
var _indentBracketContent = function(str){
	return str.replace(/\n+/g, "\n\t").replace(/\n\t}$/, "\n}");
};
/** @public
* @param {string|Array} css
* @return {string} prettified CSS string
* @example
* prettifyCss(["div", [
*   "color: red;",
*   "padding: 20px;"
* ],
* ".class", [
*   "margin: 0;"
* ]
* ]);
*/
var prettifyCss = function(css) {
	if(css) {
		var cssStr = "";
		if (Array.isArray(css)) {
			var ary = css.map(_encloseBracket);
			cssStr = ary.join("\n").replace(/{\s*{/g, "{").replace(/\s+{/g, " {");
		} else {
			cssStr = (typeof css === "string") ? css : css + "";
		}

		if(cssStr) {
			return cssStr.replace(/{[\w\W]*?}/g, _indentBracketContent);
		}
	}
	return "";
};
/** Get shadow root of the given element regardless of whether the element is in the DOM or not. The immediate shadow root parent is returned in case of nested shadow roots. Any other case return null.
* @public
* @param {Element} elem
* @return {DocumentFragment}
*/
var getShadowRoot = function(elem) {
	if(elem) {
		var rootNode;
		if(elem.shadowRoot) {
			rootNode = elem.shadowRoot;
		} else if(elem.getRootNode) {
			rootNode = elem.getRootNode();
		}
		if(rootNode) { // getRootNode does not supported in IE. It should be implemented by the polyfills
			if(rootNode !== document) { // element that is in the DOM and not in the shadow has document as its root node
				if(rootNode !== elem) { // element that is NOT in the DOM and not in the shadow has itself as its root node
					return rootNode;
				}
			}
		}
	}
	return null;
};
/** Attach style tag to the proper document (in case of element inside a shadow root)
* @public
* @param {string} cssStr Valid CSS string (e.g. "div {color: red;}")
* @param {Element=} targetContext Element that needs the CSS
* @return {Element} New style tag
*/
var injectCss = function(cssStr, targetContext) {
	if(!cssStr) {
		return null;
	}

	var styleTag = document.createElement("style");
	styleTag.textContent = "\n" + cssStr + "\n";

	var styleHost = getShadowRoot(targetContext);
	var isInShadow = true;
	if(!styleHost) {
		isInShadow = false;
		styleHost = document.head;
	}

	// Find a place to insert the style tag
	var beforeElem;
	if(isInShadow) {
		if(styleHost.children && styleHost.children.length) {
			beforeElem = styleHost.children[0];
		}
	}
	if(beforeElem) {
		styleHost.insertBefore(styleTag, beforeElem);
	} else {
		styleHost.appendChild(styleTag);
	}
	return styleTag;
};

/** return true if browser is IE or Edge
* @public
* @return {boolean}
*/
var isIE = function () {
	var ua = window.navigator.userAgent;
	return (ua.indexOf('MSIE ') > 0) || (ua.indexOf('Trident/') > 0) || (ua.indexOf('Edge/') > 0);
};

/** return true if device is mac
* @public
* @return {boolean}
*/
var isMac = function () {
	return /Mac/.test(navigator.platform);
};

/** parse nested object in to array
* @public
* @param {Object} obj
* @param {Array=} ary
* @return {Array}
*/
var nestedObjectToArray = function (obj, ary) {
	if (!ary) {
		ary = [];
	}
	for (var key in obj) {
		var element = obj[key];
		if ('object' === typeof element) {
			nestedObjectToArray(element, ary);
		} else {
			ary.push(element);
		}
	}
	return ary;
};

/** Convert CSS rgb or rgba formats to CSS hex color string (# prefix)
* @public
* @param {string} rgbCode
* @return {string}
* @example
* rgb2Hex("rgb(255, 255, 0)"); // "#FFFF00"
* rgb2Hex("rgba(255, 255, 0, 1)"); // "#FFFF00"
* rgb2Hex("255 255.0"); // "#FFFF00"
* rgb2Hex("#FFFF00"); // "#FFFF00"
* rgb2Hex("#1a1a1a"); // "#1a1a1a"
* rgb2Hex("2552550"); // "2552550"
* rgb2Hex("invalid"); // "invalid"
* rgb2Hex(null); // ""
*/
var rgb2Hex = function (rgbCode) {
	if(!rgbCode || typeof rgbCode !== "string") {
		return "";
	}
	if(rgbCode.charAt(0) === "#") {
		return rgbCode;
	}
	var rgb = rgbCode.match(/\d+/g);
	if(!rgb || rgb.length < 3) {
		return rgbCode;
	}

	var hex = "#";
	for(var i = 0; i < 3; i++) {
		var num = +rgb[i];
		if(!(num >= 16)) { // Handle NaN case
			hex += "0";
		}
		hex += (num) ? num.toString(16).toUpperCase() : "0";
	}
	return hex;
};

/** transform data to tab seperated value
* @public
* @param {*} data
* @return {string}
*/
var prepareTSVContent = function (data) {
	if (data == null) {
		return "";
	}

	var content = (typeof data === 'string') ? data : data.toString();

	if (!content.length) { return ""; }

	// Replace any new line and tab
	if (content.indexOf("\n") >= 0) {
		content = content.replace(/[\r\n]/g, " ");
	}

	if (content.indexOf("\t") >= 0) {
		content = content.replace(/\t/g, " ");
	}

	// Trim front and back spaces
	if (content.charAt(0) === " " || content.charAt(content.length - 1) === " ") {
		content = content.trim();
	}

	return content;
};

/* unused harmony default export */ var _unused_webpack_default_export = (Util);



/***/ }),
/* 2 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, "CoralButtonFormatter", function() { return /* reexport */ js_CoralButtonFormatter; });
__webpack_require__.d(__webpack_exports__, "CoralCheckboxFormatter", function() { return /* reexport */ js_CoralCheckboxFormatter; });
__webpack_require__.d(__webpack_exports__, "CoralComboBoxFormatter", function() { return /* reexport */ js_CoralComboBoxFormatter; });
__webpack_require__.d(__webpack_exports__, "CoralIconFormatter", function() { return /* reexport */ js_CoralIconFormatter; });
__webpack_require__.d(__webpack_exports__, "CoralInputFormatter", function() { return /* reexport */ js_CoralInputFormatter; });
__webpack_require__.d(__webpack_exports__, "CoralRadioButtonFormatter", function() { return /* reexport */ js_CoralRadioButtonFormatter; });
__webpack_require__.d(__webpack_exports__, "CoralSelectFormatter", function() { return /* reexport */ js_CoralSelectFormatter; });
__webpack_require__.d(__webpack_exports__, "CoralToggleFormatter", function() { return /* reexport */ js_CoralToggleFormatter; });
__webpack_require__.d(__webpack_exports__, "DuplexEmeraldDateTimePickerFormatter", function() { return /* reexport */ js_DuplexEmeraldDateTimePickerFormatter; });
__webpack_require__.d(__webpack_exports__, "EmeraldDateTimePickerFormatter", function() { return /* reexport */ js_EmeraldDateTimePickerFormatter; });
__webpack_require__.d(__webpack_exports__, "NumericInputFormatter", function() { return /* reexport */ js_NumericInputFormatter; });
__webpack_require__.d(__webpack_exports__, "PercentBarFormatter", function() { return /* reexport */ js_PercentBarFormatter; });
__webpack_require__.d(__webpack_exports__, "SimpleImageFormatter", function() { return /* reexport */ js_SimpleImageFormatter; });
__webpack_require__.d(__webpack_exports__, "SimpleInputFormatter", function() { return /* reexport */ js_SimpleInputFormatter; });
__webpack_require__.d(__webpack_exports__, "SimpleLinkFormatter", function() { return /* reexport */ js_SimpleLinkFormatter; });
__webpack_require__.d(__webpack_exports__, "SimpleTickerFormatter", function() { return /* reexport */ js_SimpleTickerFormatter; });
__webpack_require__.d(__webpack_exports__, "SimpleToggleFormatter", function() { return /* reexport */ js_SimpleToggleFormatter; });
__webpack_require__.d(__webpack_exports__, "TextFormatter", function() { return /* reexport */ js_TextFormatter; });

// EXTERNAL MODULE: ./src/js/FormatterBuilder.js
var FormatterBuilder = __webpack_require__(0);

// CONCATENATED MODULE: ./src/js/CoralButtonFormatter.js


/** @typedef {Object} CoralButtonFormatter~Options
* @description FormatterBuilder options
* @property {string=} label
*/

var onElementUpdated = function (element, ctx) {
	var label = (typeof ctx.label === "string") ? ctx.label : ctx.value;
	element.textContent = label;
};

/** @constructor
* @param {*=} options
*/
var CoralButtonFormatter = function (options) {

};

/** @public
* @param {(FormatterBuilder.Options|CoralButtonFormatter.Options|Object)=} options
* @return {Object}
*/
CoralButtonFormatter.create = function (options) {
	var defaultOpt = {
		tagName: "coral-button",
		refName: "CoralButtonFormatter",
		styles: {
			maxWidth: "100%",
			margin: "0"
		},
		onElementUpdated: onElementUpdated,
		label: null // use ctx.value by default
	};

	return FormatterBuilder["a" /* default */].create(options, defaultOpt);
};

/* harmony default export */ var js_CoralButtonFormatter = (CoralButtonFormatter);


// CONCATENATED MODULE: ./src/js/CoralCheckboxFormatter.js


var CoralCheckboxFormatter_onElementUpdated = function (element, ctx) {
	element.checked = ctx.value;
	if (ctx.labelField) {
		var text = ctx.getData(ctx.labelField);
		element.textContent = (text != null) ?  text : '';
	}
};

/** To bound data and view of the current checkbox state
* @private
* @param {*} e
* @param {*} ctx
*/
var _changeHandler = function (e, ctx) {
	ctx.value = e.detail.value;
	ctx.setData(ctx.field, ctx.value);
};

/** @constructor
* @param {*=} options
*/
var CoralCheckboxFormatter = function (options) {

};

/** @public
* @param {(FormatterBuilder.Options|Object)=} options
* @return {Object}
*/
CoralCheckboxFormatter.create = function (options) {
	var defaultOpt = {
		tagName: "coral-checkbox",
		refName: "CoralCheckboxFormatter",
		onElementUpdated: CoralCheckboxFormatter_onElementUpdated,
		changeHook: "checked-changed",
		changeHandler: _changeHandler
	};

	return FormatterBuilder["a" /* default */].create(options, defaultOpt);
};

/* harmony default export */ var js_CoralCheckboxFormatter = (CoralCheckboxFormatter);


// EXTERNAL MODULE: ./node_modules/tr-grid-util/es6/Util.js
var Util = __webpack_require__(1);

// CONCATENATED MODULE: ./node_modules/tr-grid-util/es6/Deferred.js
/** Deferred promise should be used when asynchronous method does not return promise object (e.g. typical AJAX calls, or native setTimeout()). In other words, deferred promise is used to allow any non-promise logics to be worked in promise pattern.
* @constructor
* @param {Function=} resolveHandler
* @param {Function=} rejectHandler
* @param {*=} ctx Context object that will be provided as the second parameter of the given handlers
* @example
* var def = new Deferred(handler);
* setTimeout(def.resolve, 2000);
* var def2 = new Deferred();
* setTimeout(function() {
*   def2.resolve();
* }, 4000);
*/
var Deferred = function(resolveHandler, rejectHandler, ctx) {
	this.resolve = this.resolve.bind(this);
	this.reject = this.reject.bind(this);

	if(typeof resolveHandler === "function") {
		this._resolveHandler = resolveHandler;
	}
	if(typeof rejectHandler === "function") {
		this._rejectHandler = rejectHandler;
	}
	if(ctx != null) {
		this._ctx = ctx;
	}
	this.promise = new Promise((function(resolve, reject) {
		this._resolve = resolve;
		this._reject = reject;
	}).bind(this));
};
/** @type {Promise<*>}
* @public
*/
Deferred.prototype.promise = null;
/** @type {Function}
* @private
*/
Deferred.prototype._resolve = null; // Always supplied from Promise object
/** @type {Function}
* @private
*/
Deferred.prototype._reject = null; // Always supplied from Promise object
/** @type {Function}
* @private
*/
Deferred.prototype._resolveHandler = null;
/** @type {Function}
* @private
*/
Deferred.prototype._rejectHandler = null;
/** Context object that will be provided as the second parameter of the given handlers
* @type {*}
* @private
*/
Deferred.prototype._ctx = null;


/** @public
* @param {*=} result
*/
Deferred.prototype.resolve = function(result) {
	if(this._resolve) { // Promise can be resolved only once
		if(this._resolveHandler) {
			var handlerRes = this._resolveHandler(result, this._ctx || this);
			if(handlerRes != null) {
				result = handlerRes;
			}
		}
		this._resolve(result); // WARNING: Synchronous call. The standard promise behavior requires asynchronous response.
		this._finally();
	}
};
/** @public
* @param {*=} result
*/
Deferred.prototype.reject = function(result) {
	if(this._reject) { // Promise can be resolved only once
		if(this._rejectHandler) {
			var handlerRes = this._rejectHandler(result, this._ctx || this);
			if(handlerRes != null) {
				result = handlerRes;
			}
		}
		this._reject(result); // WARNING: Synchronous call
		this._finally();
	}
};

/** @private */
Deferred.prototype._finally = function() {
	// Release all references to avoid memory leak
	this._ctx = this._resolveHandler = this._rejectHandler = null;
	this._resolve = this._reject = null;
};

/* harmony default export */ var es6_Deferred = (Deferred);


// CONCATENATED MODULE: ./node_modules/tr-grid-util/es6/ElfUtil.js



/** @namespace */
var ElfUtil = {};
/** @type {Deferred}
* @private
*/
ElfUtil._deferred = null;
/** @type {Promise<Object>}
* @public
*/
ElfUtil.themeReady = null;
/** Default theme colors from Solar Charcoal + American color profile
* @type {!Object.<string, string>}
* @private
* @const
*/
ElfUtil._defaultColors = {
	"up": "#39C46E",
	"down": "#F5475B",
	"level": "#C2C2C2",
	"tickUp": "#39C46E",
	"tickDown": "#F5475B",
	"baseGrid": "#1A1A1C", // For CellPainter. In Solar Pearl, the value would be #FFFFFF
	"baseText": "#C2C2C2", // For CellPainter. In Solar Pearl, the value would be #505050
	"trackColor": "#FF9933" // For PercentBar.
};
/** @type {Object.<string, string>}
* @public
*/
ElfUtil.themeColors = ElfUtil._defaultColors;
/** @type {Object.<string, number>}
* @private
*/
ElfUtil._components = {};
/** @type {string}
* @private
*/
ElfUtil._themeName = "";
/** @type {number}
* @private
*/
ElfUtil._elfVersion = 0;
/** @type {Element}
* @private
*/
ElfUtil._dummyIcon = null;
/** @type {boolean}
* @private
*/
ElfUtil._iconLoaded = false;

/** @type {Object.<string, Object>}
* @private
*/
ElfUtil._icons = {
	"elf-theme-halo": {
		"rowGrouping": {
			"expander": "down" // also used in rt-grid
		},
		"sorting": {
			"ascending": "hollow-arrow-up",
			"descending": "hollow-arrow-down",
			"sortable": "sort-up-down"
		},
		"columnStack": {
			"stack": "list",
			"expand": "right",
			"collapse": "left"
		}
	},
	"elf-theme-solar": {
		"columnStack": {
			"stack": "list",
			"expand": "right",
			"collapse": "left"
		}
	}
};

/** Check ELF version
* @public
* @function
* @return {number}
*/
ElfUtil.getElfVersion = function () {
	if (!ElfUtil._elfVersion) {
		var val = 0;
		if (window.elf) {
			if (window.elf.version) {
				var ver = window.elf.version.match(/\d/); // example version code: 4.0.1
				if (ver && ver[0]) {
					val = parseInt(ver[0], 10);
				}
			} else {
				if (window.elf.customElements) {
					val = 3;
				} else if (window.customElements) {
					val = 4;
				}
			}
		} else if (window.Polymer) {
			val = 1;
		}
		ElfUtil._elfVersion = val;
	}

	return ElfUtil._elfVersion;
};

/** Check if ELF component is available for usage. Returns version number of the available component.
* @public
* @function
* @param {string} compName
* @return {number}
* @example
* ElfUtil.hasComponent("coral-button"); // 1 or 3
* ElfUtil.hasComponent("unknown-button"); // 0
*/
ElfUtil.hasComponent = function (compName) {
	var val = ElfUtil._components[compName];
	if (val == null) {
		val = 0;
		var ver = ElfUtil.getElfVersion();
		if (compName) {
			var elem;
			if (ver === 1) {
				elem = document.createElement(compName);
				if (elem.is === compName) {
					val = ver;
				}
			} else if (ver > 1) {
				if (
					window.customElements && window.customElements.get(compName) // Elf v3 v4
					|| document.createElement(compName).constructor !== HTMLElement // In case doesn't polyfill elf
				) {
					val = ver;
				}
			}
			ElfUtil._components[compName] = val; // TODO: Add safeguard for retriving version before ELF
		}
	}
	return val;
};

/** Check if ELF theme is available for usage. Returns true if theme is available.
* @public
* @function
* @param {string} themeName
* @return {boolean}
* @example
* ElfUtil.hasTheme("elf-theme-solar"); // true or false
*/
ElfUtil.hasTheme = function (themeName) {
	return themeName === ElfUtil.getThemeName();
};

/** Check the current elf theme. If not available, return empty string.
* @public
* @function
* @param {Element=} optElem Deprecated param: Function will always use <html> instead
* @return {string}
*/
ElfUtil.getThemeName = function (optElem) {
	if (!ElfUtil._themeName) {
		// get theme name directly from element <html> --> document.documentElement
		ElfUtil._themeName = ElfUtil.getCssVariable("--theme-name", document.documentElement);
	}
	return ElfUtil._themeName;
};

/** Check the current elf theme. If not available, return empty string.
* @public
* @function
* @param {Object} configObj Object to mutate
* @param {Element=} optElem Deprecated param: will no longer use anymore
*/
ElfUtil.injectIcons = function (configObj, optElem) {
	if (typeof configObj !== "object") { return; }

	var theme = ElfUtil.getThemeName();
	configObj.themeName = theme;

	var ver = ElfUtil.getElfVersion();
	configObj.elfVersion = ver;

	var icons = ElfUtil._icons[theme];
	if (icons) {
		configObj.icons = icons;
	}
};

/** Get icons array list
* @public
* @function
* @returns {!Array.<string>} Always return a list of icons for the existing theme
*/
ElfUtil.getIconList = function () {
	var iconStruct = ElfUtil._icons[ElfUtil.getThemeName()];
	return iconStruct ? Object(Util["b" /* nestedObjectToArray */])(iconStruct) : [];
};

/** @private
* @function
*/
ElfUtil._onIconPreloaded = function() {
	if(ElfUtil._dummyIcon) {
		var pn = ElfUtil._dummyIcon.parentNode;
		if(pn) {
			pn.removeChild(ElfUtil._dummyIcon);
		}
		ElfUtil._dummyIcon = null;
	}
};
/** Prepare and get icons array list. This method ensures that preloading can be executed only once.
* @public
* @function
* @returns {Array.<string>} Return null if there is no icon to be preloaded. Otherwise, a list of icons is returned.
*/
ElfUtil.prepareIconPreloading = function() {
	if(!ElfUtil._iconLoaded) {
		ElfUtil._iconLoaded = true;
		var iconList = ElfUtil.getIconList();
		if(iconList.length) {
			setTimeout(ElfUtil._onIconPreloaded, 10);
			var dummyIcon = ElfUtil._dummyIcon = document.createElement("coral-icon");
			dummyIcon.style.transform = "scale(0)";
			document.body.appendChild(dummyIcon);
			return iconList;
		}
	}
	return null;
};

/** Gets any defined css variables by name/key
* @param {string} varName css variable names (with leading --)
* @param {Element=} optElem target element, fallback to document body
* @returns {string} CSS variable
* @example
* ElfUtil.getCssVariable("--valid-name");
* ElfUtil.getCssVariable("--valid-name", spanElement);
*/
ElfUtil.getCssVariable = function (varName, optElem) {
	var result = "";
	var elem = optElem || document.body;
	if (window && typeof varName === "string" && elem.nodeType === 1) {
		if (varName.match(/^--/)) {
			result = window.getComputedStyle(elem).getPropertyValue(varName);
			result = result.replace(/[\"\']/g, "");
		}
	}
	return result;
};
/** Gets multiple CSS variables from an object map for better performance
* @param {Object.<string, string>} obj Key can be anything, while value is the CSS variable name
* @param {Element=} optElem target element, fallback to document body
* @returns {Object} Returns the same given object
* @example
* ElfUtil.getCssVariables({
*   "name1": "--var1",
*   "name2": "--var2"
* }, spanElement); // Css varriable names will be replaced with their value
*/
ElfUtil.getCssVariables = function (obj, optElem) {
	var elem = optElem || document.body;
	if (window && elem.nodeType === 1) {
		var computedStyle = window.getComputedStyle(elem);
		for(var key in obj) {
			var varName = obj[key];
			if (varName && varName.match(/^--/)) {
				obj[key] = computedStyle.getPropertyValue(varName).replace(/\"/g, ""); // eslint-disable-line
			}
		}
	}
	return obj || null;
};

/** Gets current theme colors from the document and returns a promise. <br>
* WANRING: This method sets movement color profile to html tag automatically, if JET.Settings exists. <br>
* To re-request/reset theme colors, set ElfUtil.themeReady variable to null
* @public
* @return {Promise<Object>} A promise of object of theme colors
*/
ElfUtil.getThemeColors = function() {
	if(ElfUtil.themeReady) {
		return ElfUtil.themeReady;
	}
	var d = ElfUtil._deferred = new Deferred();
	ElfUtil.themeReady = d.promise;

	var jet = window ? window.JET : null;
	if(jet && jet.Settings) {
		try {
			jet.Settings.read(ElfUtil._onColorProfile, {
				providerName: "Configuration",
				settingName: "RDE_USER_CURRENT_TICK_COLOR"
			});
		} catch (err) {
			d.reject("Cannot read JET's settings");
		}
	} else {
		setTimeout(ElfUtil._retrieveThemeColors, 100); // TODO: Find a proper way to ensure that theme is ready
	}
	return d.promise;
};

/** Get user's color profile from JET and set it to html tag (document.documentElement)
* @private
* @param {string} colorProfile Returned from JET.Settings
*/
ElfUtil._onColorProfile = function (colorProfile) {
	if(colorProfile) {
		document.documentElement.setAttribute("movement-color-profile", colorProfile.toLowerCase());
	}
	ElfUtil._retrieveThemeColors();
};
/** Get current profile name set on the root html element (document.documentElement)
* @public
* @return {string} Current profile name
*/
ElfUtil.getMovementColorProfile = function() {
	return document.documentElement.getAttribute("movement-color-profile");
};

/** Get theme colors from document
* @private
*/
ElfUtil._retrieveThemeColors = function() {
	var colors = ElfUtil.themeColors = ElfUtil.getCssVariables({
		"primary": "--color-scheme-primary", // Usually used in headers, and selection
		"secondary": "--color-scheme-secondary",
		"tertiary": "--color-scheme-tertiary", // Usually black or white
		"complementary": "--color-scheme-complementary", // Usually black or white
		"up": "--color-scheme-positive",
		"down": "--color-scheme-negative",
		"level": "--color-scheme-neutral",
		"tickUp": "--color-scheme-tickup",
		"tickDown": "--color-scheme-tickdown"
	});
	if(!colors["up"]) {
		colors["up"] = ElfUtil._defaultColors["up"];
		colors["down"] = ElfUtil._defaultColors["down"];
		colors["level"] = ElfUtil._defaultColors["level"];
		colors["tickUp"] = ElfUtil._defaultColors["tickUp"];
		colors["tickDown"] = ElfUtil._defaultColors["tickDown"];
	}

	// To be consistent with Elf theme variables
	colors["positive"] = colors["up"];
	colors["negative"] = colors["down"];
	colors["neutral"] = colors["level"];

	// Retrieve table styles to be used in grid and extensions
	var tableElem = document.createElement("table");
	tableElem.style.visibility = "hidden";
	tableElem.style.position = "fixed";
	tableElem.style.left = "0"; // Activate fixed position
	tableElem.style.top = "0";
	tableElem.style.width = "0"; // Prevent creating scrollbar
	var trElem = tableElem.insertRow(-1);
	var tdElem = trElem.insertCell(-1);

	document.body.appendChild(tableElem);
	var trStyles = window.getComputedStyle(trElem);
	colors["tableBg"] = trStyles.backgroundColor; // Usually equivalent to --color-scheme-tertiary

	var tdStyles = window.getComputedStyle(tdElem);
	colors["tableText"] = tdStyles.color; // Usually equivalent to --color-scheme-neutral
	colors["tableBorder"] = tdStyles.borderColor;
	if(colors["tableText"] === colors["tableBorder"]) {
		// trElem.className = "pearl";
		tdElem.className = "tr-lg";
		tdStyles = window.getComputedStyle(tdElem);
		colors["tableBg"] = tdStyles.backgroundColor;
		colors["tableText"] = tdStyles.color;
		colors["tableBorder"] = tdStyles.borderColor; // In Solar Pearl, the value would be #DADDE0
		if(colors["tableText"] === colors["tableBorder"]) { // Last fallback for non ELF coloring
			colors["tableBg"] = ElfUtil._defaultColors["baseGrid"];
			colors["tableText"] = ElfUtil._defaultColors["baseText"];
			colors["tableBorder"] = "";
		}
	}
	// WARNING: Computed styles return rgb/rgba color format instead of hex format
	colors["tableBg"] = Object(Util["d" /* rgb2Hex */])(colors["tableBg"]);
	colors["tableText"] = Object(Util["d" /* rgb2Hex */])(colors["tableText"]);
	colors["tableBorder"] = Object(Util["d" /* rgb2Hex */])(colors["tableBorder"]);
	document.body.removeChild(tableElem);

	// For CellPainter backward compatability
	colors["baseGrid"] = colors["tableBg"];
	colors["baseText"] = colors["tableText"];
	colors["trackColor"] = colors["primary"] || ElfUtil._defaultColors["trackColor"];

	ElfUtil._deferred.resolve(colors);
};


/* harmony default export */ var es6_ElfUtil = (ElfUtil);


// CONCATENATED MODULE: ./src/js/CoralComboBoxFormatter.js



/** @typedef {Object} CoralComboBoxFormatter~Options
* @description CoralComboBoxFormatter options
* @property {Array=} data Item list to be displayed on the coral select. The given object should contains at least value properties. If string is given, it will be treated as the value.
* @property {Array=} entries Alias to `data` property
* @property {Array=} items Alias to `data` property
*/

/** @private
* @param {Object} ctx Context object
* @param {Object} options User options
*/
var onContextCreated = function (ctx, options) {
	var userItems = options.data || options.entries || options.items;
	if(Array.isArray(userItems)) {
		var i;
		var len = userItems.length;
		for(i = 0; i < len; ++i) {
			var userItem = userItems[i];
			if(userItem != null) {
				if (typeof userItem !== "object") {
					userItem = { value: userItem };
				}
			} else {
				userItem = {value: ""};
			}
			var label = userItem.label;
			if(!label && typeof label !== "string") { // 0, false, null, undefined, NaN
				userItem.label = userItem.value + "";
			}
			userItems[i] = userItem;
		}
		ctx.data = userItems;

		var mappedData = ctx._mappedData = {}; // WORKAROUND: Since combobox does not accept raw value for selection, it actually needs item element
		for (i = 0; i < len; ++i) {
			userItem = userItems[i];
			mappedData[userItem.value] = userItem;
		}
	}
};

var onElementCreated = function (element, ctx) {
	element.data = ctx.data;
};

var CoralComboBoxFormatter_onElementUpdated = function (element, ctx) {
	if (ctx._mappedData) {
		if(es6_ElfUtil.getElfVersion() > 3) {
			element.value = ctx.value;
		} else {
			element.value = ctx._mappedData[ctx.value];
		}
	}
};

var CoralComboBoxFormatter_changeHandler = function (e, ctx) {
	if (e.detail.value == null) {
		return;
	}
	if(es6_ElfUtil.getElfVersion() > 3) {
		ctx.value = e.detail.value;
	} else {
		ctx.value = e.detail.value.value;
	}
	ctx.setData(ctx.field, ctx.value);
};

/** @constructor
* @param {*=} options
*/
var CoralComboBoxFormatter = function (options) {

};

/** @public
* @param {(FormatterBuilder.Options|CoralComboBoxFormatter.Options|Object)=} options
* @return {Object}
*/
CoralComboBoxFormatter.create = function (options) {
	var defaultOpt = {
		tagName: "coral-combo-box",
		refName: "CoralComboBoxFormatter",
		styles: {
			maxWidth: "100%",
			margin: "0"
		},
		onContextCreated: onContextCreated,
		onElementCreated: onElementCreated,
		onElementUpdated: CoralComboBoxFormatter_onElementUpdated,
		changeHook: "value-changed",
		changeHandler: CoralComboBoxFormatter_changeHandler,
		data: null
	};

	return FormatterBuilder["a" /* default */].create(options, defaultOpt);
};

/* harmony default export */ var js_CoralComboBoxFormatter = (CoralComboBoxFormatter);


// CONCATENATED MODULE: ./src/js/CoralIconFormatter.js


/** @typedef {Object} CoralIconFormatter~Options
* @description FormatterBuilder options
* @property {(string|Object)=} icon
* @property {(number|string)=} size
*/

var CoralIconFormatter_onElementUpdated = function (element, ctx) {
	var icon = ctx.value;
	if (ctx.icon != null && typeof ctx.icon === "object") {
		icon = ctx.icon[ctx.value];
	}
	if (typeof ctx.icon === "string") {
		icon = ctx.icon;
	}
	element.icon = icon;
	element.size = ctx.size;
};

/** @constructor
* @param {*=} options
*/
var CoralIconFormatter = function (options) {

};

/** @public
* @param {(FormatterBuilder.Options|CoralIconFormatter.Options|Object)=} options
* @return {Object}
*/
CoralIconFormatter.create = function (options) {
	var defaultOpt = {
		tagName: "coral-icon",
		refName: "CoralIconFormatter",
		onElementUpdated: CoralIconFormatter_onElementUpdated,
		icon: null, // use icon from ctx.value
		size: 15
	};

	return FormatterBuilder["a" /* default */].create(options, defaultOpt);
};

/* harmony default export */ var js_CoralIconFormatter = (CoralIconFormatter);


// CONCATENATED MODULE: ./src/js/CoralInputFormatter.js


var CoralInputFormatter_onElementUpdated = function (element, ctx) {
	element.value = ctx.value;
};

var CoralInputFormatter_changeHandler = function (e, ctx) {
	ctx.value = e.detail.value;
	ctx.setData(ctx.field, ctx.value);
};

/** @constructor
* @param {*=} options
*/
var CoralInputFormatter = function (options) {

};

/** @public
* @param {(FormatterBuilder.Options|Object)=} options
* @return {Object}
*/
CoralInputFormatter.create = function (options) {
	var defaultOpt = {
		tagName: "coral-input",
		refName: "CoralInputFormatter",
		onElementUpdated: CoralInputFormatter_onElementUpdated,
		changeHook: "value-changed",
		changeHandler: CoralInputFormatter_changeHandler,
		styles: {
			margin: "0",
			width: "100%"
		}
	};

	return FormatterBuilder["a" /* default */].create(options, defaultOpt);
};

/* harmony default export */ var js_CoralInputFormatter = (CoralInputFormatter);


// CONCATENATED MODULE: ./src/js/CoralRadioButtonFormatter.js


/** @typedef {Object} CoralRadioButtonFormatter~Options
* @description FormatterBuilder options
* @property {number=} initialIndex
*/

var CoralRadioButtonFormatter_onElementCreated = function (element, ctx) {
	var dv = ctx.grid.getDataSource();
	var rid = dv.getRowId(ctx.rowIndex);
	var index = dv.getRowIndex(rid);
	var checked = index === ctx.initialIndex;
	if (checked) {
		ctx.previousId = rid;
		ctx.setData(ctx.field, checked);
	}
	ctx.value = checked;
};

var CoralRadioButtonFormatter_onElementUpdated = function (element, ctx) {
	var dv = ctx.grid.getDataSource();
	var rid = dv.getRowId(ctx.rowIndex);
	var checked = (rid === ctx.previousId) && ctx.value;
	element.checked = checked;
};

/** To bound data and view of the current focus radio button
* @private
* @param {*} e
* @param {*} ctx
*/
var CoralRadioButtonFormatter_changeHandler = function (e, ctx) {
	ctx.value = e.detail.value;
	ctx.setData(ctx.field, ctx.value);

	var dv = ctx.grid.getDataSource();
	var rid = dv.getRowId(ctx.rowIndex);
	if (ctx.previousId && ctx.previousId !== rid) {
		var row = dv.getRowData(ctx.previousId);
		if (row) {
			if (row["ROW_DEF"]) {
				row["ROW_DEF"].setData(ctx.field, false);
			} else {
				dv.setData(ctx.previousId, ctx.field, false);
			}
		}
	}
	ctx.previousId = dv.getRowId(ctx.rowIndex);
};

/** @constructor
* @param {*=} options
*/
var CoralRadioButtonFormatter = function (options) {

};

/** @public
* @param {(FormatterBuilder.Options|CoralRadioButtonFormatter.Options|Object)=} options
* @return {Object}
*/
CoralRadioButtonFormatter.create = function (options) {
	var defaultOpt = {
		tagName: "coral-radio-button",
		refName: "CoralRadioButtonFormatter",
		styles: {
			margin: 0
		},
		onElementCreated: CoralRadioButtonFormatter_onElementCreated,
		onElementUpdated: CoralRadioButtonFormatter_onElementUpdated,
		changeHook: "checked-changed",
		changeHandler: CoralRadioButtonFormatter_changeHandler,
		initialIndex: -1 // does not checked by default
	};

	return FormatterBuilder["a" /* default */].create(options, defaultOpt);
};

/* harmony default export */ var js_CoralRadioButtonFormatter = (CoralRadioButtonFormatter);


// CONCATENATED MODULE: ./node_modules/tr-grid-util/es6/CoralItems.js
/** @namespace */
var CoralItems = {};

/** Create new array with valid object items to be consumed by coral-select's data property from the given input
* @public
* @function
* @param {Array} userItems This can be array of anything (e.g. texts, numbers, objects or etc.).
* @return {Array.<Object>} Valid data objects for generating coral-item by coral-select
* @example
* CoralItems.create(["a", "b"]); // [{label: "a", value: "a"}, {label: "b", value: "b"}]
* CoralItems.create([33]); // [{label: "33", value: 33}]
* CoralItems.create([null]); // [{label: "", value: ""}]
* CoralItems.create([{value: false}]); // [{label: "false", value: false}]
* CoralItems.create([{label: "a", value: "b"}]); // [{label: "a", value: "b"}]
* CoralItems.create("invalid parameter"); // null
*/
CoralItems.create = function(userItems) {
	if(Array.isArray(userItems)) {
		var len = userItems.length;
		var ary = new Array(len);
		for(var i = 0; i < len; ++i) {
			var userItem = userItems[i];
			if(userItem != null) {
				if (typeof userItem !== "object") {
					userItem = { value: userItem };
				}
			} else {
				userItem = {value: ""};
			}
			var label = userItem.label;
			if(!label && typeof label !== "string") { // 0, false, null, undefined, NaN
				userItem.label = userItem.value + "";
			}
			ary[i] = userItem;
		}
		return ary;
	}
	return null;
};

/* harmony default export */ var es6_CoralItems = (CoralItems);


// CONCATENATED MODULE: ./src/js/CoralSelectFormatter.js



/** @typedef {Object} CoralSelectFormatter~Options
* @description CoralSelectFormatter options
* @property {Array=} data Item list to be displayed on the coral select. The given object should contains at least value properties. If string is given, it will be treated as the value.
* @property {Array=} entries Alias to `data` property
* @property {Array=} items Alias to `data` property
*/

/** @private
* @param {Object} ctx Context object
* @param {Object} options User options
*/
var CoralSelectFormatter_onContextCreated = function (ctx, options) {
	var userItems = options.data || options.entries || options.items;
	ctx.data = es6_CoralItems.create(userItems);
};

var CoralSelectFormatter_onElementCreated = function (element, ctx) {
	if (ctx.data) {
		element.data = ctx.data;
	}
};

var CoralSelectFormatter_onElementUpdated = function (element, ctx) {
	element.value = ctx.value;
};

var CoralSelectFormatter_changeHandler = function (e, ctx) {
	ctx.value = e.detail.value;
	ctx.setData(ctx.field, ctx.value);
};

/** @constructor
* @param {*=} options
*/
var CoralSelectFormatter = function (options) {

};

/** @public
* @param {(FormatterBuilder.Options|CoralSelectFormatter.Options|Object)=} options
* @return {Object}
*/
CoralSelectFormatter.create = function (options) {
	var defaultOpt = {
		tagName: "coral-select",
		refName: "CoralSelectFormatter",
		styles: {
			maxWidth: "100%",
			margin: "0"
		},
		onContextCreated: CoralSelectFormatter_onContextCreated,
		onElementCreated: CoralSelectFormatter_onElementCreated,
		onElementUpdated: CoralSelectFormatter_onElementUpdated,
		changeHook: "value-changed",
		changeHandler: CoralSelectFormatter_changeHandler,
		data: null
	};

	return FormatterBuilder["a" /* default */].create(options, defaultOpt);
};

/* harmony default export */ var js_CoralSelectFormatter = (CoralSelectFormatter);


// CONCATENATED MODULE: ./src/js/CoralToggleFormatter.js


/** @private
* @function
* @param {Element} element
* @param {Object} ctx
*/
var CoralToggleFormatter_onElementUpdated = function (element, ctx) {
	element.checked = ctx.value;
};

/** To bound data and view of the current coral-toggle state
* @private
* @function
* @param {*} e
* @param {*} ctx
*/
var CoralToggleFormatter_changeHandler = function (e, ctx) {
	ctx.value = e.detail.value;
	ctx.setData(ctx.field, ctx.value);
};

/** @constructor
* @param {*=} options
*/
var CoralToggleFormatter = function (options) {

};

/** @public
* @param {(FormatterBuilder.Options|Object)=} options
* @return {Object}
*/
CoralToggleFormatter.create = function (options) {
	var defaultOpt = {
		tagName: "coral-toggle",
		refName: "CoralToggleFormatter",
		onElementUpdated: CoralToggleFormatter_onElementUpdated,
		changeHook: "checked-changed",
		changeHandler: CoralToggleFormatter_changeHandler
	};

	return FormatterBuilder["a" /* default */].create(options, defaultOpt);
};

/* harmony default export */ var js_CoralToggleFormatter = (CoralToggleFormatter);


// CONCATENATED MODULE: ./node_modules/tr-grid-util/es6/ElfDate.js
/** @namespace */
var ElfDate = {};

/** Check ELF version
* @public
* @function
* @param {*} val String, number, array and any other types are acceptable
* @return {Date} Native Date object or null for Invalid Date
* @example
* ElfDate.from(1000);         // Thu Jan 01 1970 07:00:01 GMT+0700 (Indochina Time)
* ElfDate.from("2000/12/2");  // Sat Dec 02 2000 00:00:00 GMT+0700 (Indochina Time)
* ElfDate.from("2000-12-2");  // Sat Dec 02 2000 00:00:00 GMT+0700 (Indochina Time)
* ElfDate.from([2000, 11, 2]);// Sat Dec 02 2000 07:00:00 GMT+0700 (Indochina Time)
* ElfDate.from("2/12/2000");  // Sat Feb 12 2000 00:00:00 GMT+0700 (Indochina Time)
* ElfDate.from("20/12/2000"); // null
* ElfDate.from(new Date("Invalid")); // null
*/
ElfDate.from = function (val) {
	if(val) {
		var d = val;
		if(typeof val === "string" || typeof val === "number") {
			d = new Date(val);
		} else if(Array.isArray(val)) {
			d = new Date(Date.UTC(val[0] || 0, val[1] || 0, val[2] || 0));
		}
		if(ElfDate.isValid(d)) {
			return d;
		}
	}
	return null;
};

/** @public
* @function
* @param {Date} d Native Date object
* @return {boolean}
*/
ElfDate.isValid = function (d) {
	if(d && d.getTime) { // Date object must have getTime method
		var ms = d.getTime(); // millisecond since 1 first january 1970
		return ms === ms; // Invalid Date will have NaN as its value
	}
	return false;
};

/** @public
* @function
* @param {number} n
* @return {string}
* @example
* ElfDate.prefixSingleDigit(9); // "09"
* ElfDate.prefixSingleDigit(0); // "00"
* ElfDate.prefixSingleDigit(10); // "10"
*/
ElfDate.prefixSingleDigit = function (n) {
	return (n < 10 && n >= 0) ? "0" + n : "" + n;
};

/** @type {RegExp}
* @private
*/
ElfDate._ymdRe = /^\d{4}\-d{2}\-\d{2}/; // eslint-disable-line

/** Returns yyyy-MM-dd string format for emerald-datetime-picker.
* @public
* @function
* @param {string|Date} d
* @return {string} Return string for valid date, otherwise empty string
* @example
* ElfDate.toYMD(new Date("2000/1/1")); // "2000-01-01"
* ElfDate.toYMD("2000/1/1"); // "2000-01-01"
*/
ElfDate.toYMD = function (d) {
	if(typeof d === "string") {
		if(ElfDate._ymdRe.test(d)) {
			return d; // pass through only if we have yyyy-MM-dd
		}
	}
	var dateObj = ElfDate.from(d);
	if(dateObj) {
		return dateObj.getFullYear() + "-" +
			ElfDate.prefixSingleDigit(dateObj.getMonth() + 1) + "-" +
			ElfDate.prefixSingleDigit(dateObj.getDate());
	}
	return "";
};

/** @public
* @function
* @param {Element} edtp Emerald date-time picker element
* @param {*} val
*/
ElfDate.setDate = function (edtp, val) {
	if (edtp) {
		if(edtp.isAttached) { // Only Polymer element has isAttached property
			edtp.value = ElfDate.from(val);
		} else {
			edtp.value = ElfDate.toYMD(val);
		}
	}
};
/** @public
* @function
* @param {Element} edtp Emerald date-time picker element
* @return {Date} Native Date object
*/
ElfDate.getDate = function (edtp) {
	return (edtp) ? ElfDate.from(edtp.value) : null;
};

/** @public
* @function
* @param {*} valA
* @param {*} valB
* @return {number} Return nagative value if A < B, positive value if A > B, and 0 if A === B
*/
ElfDate.compare = function (valA, valB) {
	if(valA !== valB) {
		valA = ElfDate.from(valA);
		valB = ElfDate.from(valB);
		if(valA) {
			if(valB) {
				if(valA < valB) {
					return -1;
				} else if(valA > valB) {
					return 1;
				}
			} else {
				return 1;
			}
		} else if(valB) {
			return -1;
		}
	}
	return 0;
};
/** @public
* @function
* @param {*} valA
* @param {*} valB
* @return {boolean} true if the two has the same value
*/
ElfDate.equal = function (valA, valB) {
	return !ElfDate.compare(valA, valB);
};

/** Extract date part from the given date object to exclude time part and timezone. <br>
* Use ElfDate.from to convert array back to date object.
* @public
* @function
* @param {Date} d
* @return {Array.<number>} Array with 3 numbers. Return null for invalid date
*/
ElfDate.extractDate = function (d) {
	if(ElfDate.isValid(d)) {
		return [d.getFullYear(), d.getMonth(), d.getDate()];
	}
	return null;
};


/* harmony default export */ var es6_ElfDate = (ElfDate);


// CONCATENATED MODULE: ./src/js/DuplexEmeraldDateTimePickerFormatter.js




var onDuplexContextCreated = function (ctx, options) {
	ctx.ElfDate = es6_ElfDate;
	ctx.fromField = options.from;
	ctx.toField = options.to;
};

var _onElementUpdated = function (element, ctx) {
	var from = ctx.ElfDate.from(ctx.getData(ctx.fromField));
	var to = ctx.ElfDate.from(ctx.getData(ctx.toField));

	if(!ctx.ElfDate.equal(element.from, from)) {
		element.from = from;
	}
	if(!ctx.ElfDate.equal(element.to, to)) {
		element.to = to;
	}
};

var _onElfV4ElementUpdated = function (element, ctx) {
	var from = ctx.ElfDate.from(ctx.getData(ctx.fromField));
	var to = ctx.ElfDate.from(ctx.getData(ctx.toField));

	element.values = [ctx.ElfDate.toYMD(from), ctx.ElfDate.toYMD(to)];
};

var _onFieldFromBound = function (e, ctx) {
	var from = ctx.ElfDate.from(e.currentTarget.from);
	var currentData = ctx.getData(ctx.fromField);
	if (!ctx.ElfDate.equal(currentData, from)) {
		ctx.setData(ctx.fromField, from);
	}
};

var _onFieldToBound = function (e, ctx) {
	var to = ctx.ElfDate.from(e.currentTarget.to);
	if (to == null) {
		return;
	}
	var currentData = ctx.getData(ctx.toField);
	if (!ctx.ElfDate.equal(currentData, to)) {
		ctx.setData(ctx.toField, to);
	}
};

/** @private
* @param {Object} e
* @param {Object} ctx
*/
var _onElfV4ValueChanged = function (e, ctx) {
	var dates = e.currentTarget.values;
	var from = null;
	var to = null;
	if(typeof dates === "string") {
		dates = dates.split(",");
	}
	if(Array.isArray(dates)) {
		from = ctx.ElfDate.from(dates[0]);
		to = ctx.ElfDate.from(dates[1]);
	}
	if(!from || !to) {
		return;
	}

	var currentData = ctx.getData(ctx.fromField);
	if (!ctx.ElfDate.equal(currentData, from)) {
		ctx.setData(ctx.fromField, from);
	}

	currentData = ctx.getData(ctx.toField);
	if (!ctx.ElfDate.equal(currentData, to)) {
		ctx.setData(ctx.toField, to);
	}
};

/** @constructor
* @param {*=} options
*/
var DuplexEmeraldDateTimePickerFormatter = function (options) {

};

/** @public
* @param {(FormatterBuilder.Options|Object)=} options
* @return {Object}
*/
DuplexEmeraldDateTimePickerFormatter.create = function (options) {
	var defaultOpt = {
		tagName: "emerald-datetime-picker",
		refName: "DuplexEmeraldDateTimePickerFormatter",
		onContextCreated: onDuplexContextCreated,
		onElementUpdated: _onElementUpdated,
		attributes: {
			range: "",
			duplex: ""
		},
		styles: {
			margin: "0"
		}
	};

	if(es6_ElfUtil.getElfVersion() >= 4) {
		defaultOpt.onElementUpdated = _onElfV4ElementUpdated;
		defaultOpt.changeHook = "value-changed";
		defaultOpt.changeHandler = _onElfV4ValueChanged;
	} else {
		defaultOpt.changeHooks = ["from-changed", "to-changed"];
		defaultOpt.changeHandlers = [_onFieldFromBound, _onFieldToBound];
	}

	return FormatterBuilder["a" /* default */].create(options, defaultOpt);
};


/* harmony default export */ var js_DuplexEmeraldDateTimePickerFormatter = (DuplexEmeraldDateTimePickerFormatter);


// CONCATENATED MODULE: ./src/js/EmeraldDateTimePickerFormatter.js



/** Due to stamping techinue is used in the FormatterBuilder, we have to store the constructor in context object
* @private
* @param {Object} ctx Context object
* @param {Object} options User options
*/
var EmeraldDateTimePickerFormatter_onContextCreated = function (ctx, options) {
	ctx.ElfDate = es6_ElfDate;
};

var EmeraldDateTimePickerFormatter_onElementUpdated = function (element, ctx) {
	if (!ctx.ElfDate.equal(element.value, ctx.value)) {
		ctx.ElfDate.setDate(element, ctx.value);
	}
};

var EmeraldDateTimePickerFormatter_changeHandler = function (e, ctx) {
	ctx.value = ctx.ElfDate.getDate(e.detail);
	var currentData = ctx.getData(ctx.field);
	if (!ctx.ElfDate.equal(currentData, ctx.value)) {
		ctx.setData(ctx.field, ctx.value);
	}
};

/** @constructor
* @param {*=} options
*/
var EmeraldDateTimePickerFormatter = function (options) {

};

/** @public
* @param {(FormatterBuilder.Options|Object)=} options
* @return {Object}
*/
EmeraldDateTimePickerFormatter.create = function (options) {
	var defaultOpt = {
		tagName: "emerald-datetime-picker",
		refName: "EmeraldDateTimePickerFormatter",
		onContextCreated: EmeraldDateTimePickerFormatter_onContextCreated,
		onElementUpdated: EmeraldDateTimePickerFormatter_onElementUpdated,
		changeHook: "value-changed",
		changeHandler: EmeraldDateTimePickerFormatter_changeHandler,
		styles: {
			margin: "0"
		}
	};

	return FormatterBuilder["a" /* default */].create(options, defaultOpt);
};

/* harmony default export */ var js_EmeraldDateTimePickerFormatter = (EmeraldDateTimePickerFormatter);


// CONCATENATED MODULE: ./src/js/NumericInputFormatter.js



var NumericInputFormatter_onElementUpdated = function (element, ctx) {
	element.value = ctx.value;
};

var NumericInputFormatter_onElementCreated = function (element, ctx) {
	element.setAttribute("type", "number");
};

var NumericInputFormatter_changeHandler = function (e, ctx) {
	ctx.value = e.detail.value;
	ctx.setData(ctx.field, ctx.value);
};

var _inputChangeHandler = function (e, ctx) {
	ctx.value = +e.currentTarget.value;
	ctx.setData(ctx.field, ctx.value);
};

/** @constructor
* @param {*=} options
*/
var NumericInputFormatter = function (options) {

};

/** @public
* @param {(FormatterBuilder.Options|Object)=} options
* @return {Object}
*/
NumericInputFormatter.create = function (options) {
	var tn = "input";
	if(es6_ElfUtil.hasComponent("coral-number-field")) {
		tn = "coral-number-field";
	} else if(es6_ElfUtil.hasComponent("coral-input")) {
		tn = "coral-input";
	}

	var defaultOpt = {
		tagName: tn,
		refName: "NumericInputFormatter",
		onElementUpdated: NumericInputFormatter_onElementUpdated,
		changeHook: "value-changed",
		changeHandler: NumericInputFormatter_changeHandler,
		styles: {
			margin: "0",
			width: "100%"
		}
	};
	if(tn !== "coral-number-field") {
		defaultOpt.onElementCreated = NumericInputFormatter_onElementCreated;
		if(tn === "input") {
			defaultOpt.changeHook = "change";
			defaultOpt.changeHandler = _inputChangeHandler;
		}
	}

	return FormatterBuilder["a" /* default */].create(options, defaultOpt);
};

/* harmony default export */ var js_NumericInputFormatter = (NumericInputFormatter);


// CONCATENATED MODULE: ./node_modules/tr-grid-util/es6/Dom.js
/** @namespace */
var Dom = {};

/** Shorthand for creating an element with class
* @public
* @function
* @param {string} tagName
* @param {string=} className
* @return {!Element}
*/
Dom.create = function(tagName, className) {
	var elem = document.createElement(tagName);
	if(className) {
		elem.className = className;
	}
	return elem;
};
/** Shorthand for creating a div element with class
* @public
* @function
* @param {string=} className
* @return {!Element}
*/
Dom.div = function(className) {
	return Dom.create("div", className);
};
/** Shorthand for creating a span element with textContent
* @public
* @function
* @param {string=} textContent
* @param {string=} className
* @return {!Element}
*/
Dom.text = function(textContent, className) {
	var elem = Dom.create("span", className);
	if(textContent || textContent === 0) {
		elem.textContent = textContent;
	}
	return elem;
};

/** Shorthand for appending multiple children
* @public
* @function
* @param {Element} parentElem
* @param {...Node|Array} children
* @return {Element} Parent element
*/
Dom.appendChild = function(parentElem, children) {
	if(!parentElem) {
		return null;
	}
	var i, ary;
	if(Array.isArray(arguments[1])) {
		ary = arguments[1];
		i = 0;
	} else {
		ary = arguments;
		i = 1;
	}
	var len = ary.length;
	while(i < len) {
		parentElem.appendChild(ary[i]);
		++i;
	}
	return parentElem;
};
/** Shorthand for appending multiple children in a tree like manner
* @public
* @function
* @param {Element} parentElem
* @param {...Node|Array} children The first child from the given array will be treated as a parent of all subsequence items.
* @return {Element} Parent element
* @example
* Dom.buildTree(p1,
*   ch1,
*   ch2,
*   [ch3_p1,
*	 ch3_ch1,
*	 ch3_ch2
*   ]
* );
*/
Dom.buildTree = function(parentElem, children) {
	if(!parentElem) {
		return null;
	}
	var args = arguments;
	var len = args.length;
	for(var i = 1; i < len; ++i) {
		var child = args[i];
		if(child) {
			var childElem;
			if(Array.isArray(child)) {
				childElem = Dom.buildTree.apply(null, child);
			} else if(child.nodeType === 1) {
				childElem = /** @type{Element} */(child);
			}
			if(childElem) {
				parentElem.appendChild(childElem);
			}
		}
	}
	return parentElem;
};
/** Put the given element out of the document
* @function
* @param {Node|Element} child
* @return {Element} Parent Element
*/
Dom.removeParent = function (child) {
	if(!child) { return null; }
	var parent = child.parentNode;
	if(parent) {
		parent.removeChild(child);
	}
	return parent;
};
/** Safely set parent for the specified child element
* @function
* @param {Node|Element} child
* @param {Node|Element} parent
* @return {Element} Parent Element
*/
Dom.setParent = function (child, parent) {
	if(!child) { return null; }
	if(parent) {
		parent.appendChild(child);
		return parent;
	} else {
		return Dom.removeParent(child);
	}
};
/** Remove all child nodes
* @function
* @param {Node|Element} elem
* @param {number=} count
*/
Dom.removeChildren = function (elem, count) {
	if(elem) {
		var childCount = elem.childNodes.length;
		if(count == null || count > childCount) {
			count = childCount;
		}
		while(--count >= 0) {
			elem.removeChild(elem.lastChild);
		}
	}
};
/** Ensure that element will contain only the given nodes (all other existing nodes are removed).
* @public
* @function
* @param {Element} elem
* @param {*} val Element, Node, string, number, or everything else.
*/
Dom.setContent = function(elem, val) {
	if(elem) {
		if(val || val === 0) {
			var nt = val.nodeType;
			if(nt === 1 || nt === 3) {
				if(val !== elem.lastChild) {
					Dom.removeChildren(elem);
					elem.appendChild(/** @type{Node} */(val));
				}
			} else if(Array.isArray(val)) {
				Dom.removeChildren(elem); // Could be slow, if duplicates are given
				Dom.appendChild(elem, val);
			} else {
				elem.textContent = val; // Implicit text conversion
			}
		} else {
			Dom.removeChildren(elem);
		}
	}
};

/** A quick way to toggle attribute on and off.
* @function
* @param {Element} elem
* @param {string} attr Attribute name (e.g. disabled, readonly, style, class)
* @param {*=} bool Truthy or falsy value. If specified, this method is equivalent to setter method.
*/
Dom.toggleAttribute = function (elem, attr, bool) {
	if(bool) {
		elem.setAttribute(attr, (typeof bool === "string") ? bool : "");
	} else if(bool == null) {
		if(elem.hasAttribute(attr)) {
			elem.removeAttribute(attr);
		} else {
			elem.setAttribute(attr, "");
		}
	} else {
		elem.removeAttribute(attr);
	}
};
/** A quick way to toggle class on and off. Note that this is a replacement for classList.toggle() as IE10 doesn't support it.
* @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Element/classList}
* @function
* @param {Element} elem
* @param {string} classStr Non space class name
* @param {*=} bool Truthy or falsy value. If specified, this method is equivalent to setter method.
*/
Dom.toggleClass = function (elem, classStr, bool) {
	if(bool) {
		elem.classList.add(classStr);
	} else if(bool == null) {
		if(elem.classList.contains(classStr)) {
			elem.classList.remove(classStr);
		} else {
			elem.classList.add(classStr);
		}
	} else {
		elem.classList.remove(classStr);
	}
};
/** A quick way to add multiple classes without altering existing classes in the element. This does not necessarily mean that this method has high performance.
* @function
* @param {Element} elem
* @param {...string} classes CSS Class names without any space in the name. Array can be given as well
* @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Element/classList}
*/
Dom.addClasses = function (elem, classes) {
	if(elem) {
		var ary = Array.isArray(classes) ? classes : arguments;
		var len = ary.length;
		for(var i = 0; i < len; ++i) {
			var str = ary[i];
			if(str && typeof str == "string") {
				elem.classList.add(str);
			}
		}
	}
};
/** A quick way to remove multiple classes without altering unrelated classes in the element. This does not necessarily mean that this method has high performance.
* @function
* @param {Element} elem
* @param {...string} classes CSS Class names without any space in the name. Array can be given as well
* @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Element/classList}
*/
Dom.removeClasses = function (elem, classes) {
	if(elem) {
		var ary = Array.isArray(classes) ? classes : arguments;
		var len = ary.length;
		for(var i = 0; i < len; ++i) {
			var str = ary[i];
			if(str && typeof str == "string") {
				elem.classList.remove(str);
			}
		}
	}
};

/** @public
* @function
* @param {Event} e
*/
Dom.preventDefault = function(e) {
	e.preventDefault();
	e.stopPropagation();
};
/** @public
* @function
* @param {Event} e
*/
Dom.stopPropagation = function(e) {
	e.stopPropagation();
};


/** Get client prosition from the given target. Supports only for modern browser (Gecko 1.9+, modern Webkit)
* @public
* @function
* @param {!Element|Event|MouseEvent} target
* @param {*=} retObj An object that stores returned values
* @return {!Object} Return object with property x and y
*/
Dom.getClientPosition = function(target, retObj) {
	var pos = retObj || {"x": 0, "y": 0};
	if(target["getBoundingClientRect"]){
		var box = target["getBoundingClientRect"]();
		pos["x"] = box.left;
		pos["y"] = box.top;
	} else { //Event
		pos["x"] = target.clientX;
		pos["y"] = target.clientY;
	}

	return /**@type {!Object} */(pos);
};
/** Get position of A element that is relative to the B element. <br>
* Top-left of B is used as registration a point (0, 0) for x and y. <br>
* For example, if A is located to right of B, "x" will be positive, If A is located below B, "y" will be positive.
* @public
* @function
* @param {!Element|Event|MouseEvent} A HTMLElement, Browser's event, or mouse event object
* @param {!Element|Event|MouseEvent} B HTMLElement, Browser's event, or mouse event object
* @param {*=} retObj An object that stores returned values
* @return {!Object} an object with "x" and "y" values
* @example
* Dom.getRelativePosition(popupA, document.body); // Get position of popupA that is relative to the document body
*/
Dom.getRelativePosition = function(A, B, retObj) {
	retObj = Dom.getClientPosition(A, retObj);
	var bp = Dom.getClientPosition(B);

	retObj["x"] -= bp["x"];
	retObj["y"] -= bp["y"];
	return /**@type {!Object} */(retObj);
};
/** Return closest ancestor element or the element itself with specified class string. Otherwise return null
* @public
* @function
* @param {Element|Node|undefined} elem
* @param {string} classStr The class string can only be one single class without spaces
* @return {Element}
*/
Dom.closestElement = function(elem, classStr) {
	var n = elem;
	while(n && n.classList) {
		if(n.classList.contains(classStr)) {
			return /** @type{Element} */(n);
		}
		n = n.parentNode;
	}
	return null;
};
/** Return closest ancestor element or the element itself with the specified tagName. Otherwise return null
* @public
* @function
* @param {Element|Node|undefined} elem
* @param {string} tn Tag name in uppercase format (e.g. "DIV")
* @return {Element}
*/
Dom.closestTagName = function(elem, tn) {
	var n = elem;
	while(n && n.tagName) {
		if(n.tagName == tn) {
			return /** @type{Element} */(n);
		}
		n = n.parentNode;
	}
	return null;
};

/* harmony default export */ var es6_Dom = (Dom);


// CONCATENATED MODULE: ./node_modules/tr-grid-util/es6/PercentBar.js




/** Provides UI for simple percent bar
* @constructor
* @param {Element=} elem
*/
var PercentBar = function (elem) {
	this._topNode = elem || Dom.div();
	this._topNode._percentBar = this; // HACK: For internal reference by PercentBarRenderer
	this._topNode.classList.add("tr-percent-bar");

	this._bar = Dom.div();
	this._track = Dom.div();
	this._track.appendChild(this._bar);

	this._txt = Dom.create("span");
	this.setAlignment("c");
};

/** @type {Element}
* @private
*/
PercentBar.prototype._topNode = null;
/** @type {Element}
* @private
*/
PercentBar.prototype._track = null;
/** @type {Element}
* @private
*/
PercentBar.prototype._bar = null;
/** @type {Element}
* @private
*/
PercentBar.prototype._txt = null;

/** @type {string}
* @private
*/
PercentBar.prototype._textWidth = "56px"; // 56 is the exact fit to the default format

/** @type {boolean}
* @private
*/
PercentBar.prototype._textHidden = false;

/** @type {string}
* @private
*/
PercentBar.prototype._alignment;
/** @type {number}
* @private
*/
PercentBar.prototype._absValue;
/** @type {number}
* @private
*/
PercentBar.prototype._maxValue = 100;
/** Sign of value. 1 for positive and -1 for negative.
* @type {number}
* @private
*/
PercentBar.prototype._sign = 1;
/** @type {boolean}
* @private
*/
PercentBar.prototype._dirtySign = true;
/** @type {boolean}
* @private
*/
PercentBar.prototype._invalid = false;

/** @type {boolean}
* @private
*/
PercentBar.prototype._movementColorUsed = true;

/** @type {boolean}
* @private
*/
PercentBar.prototype._tooltipEnabled = true;

/** @type {string}
* @private
*/
PercentBar._styles = Object(Util["c" /* prettifyCss */])([
	".tr-percent-bar", [
		"position: relative;",
		"text-align: left;",
		"overflow: hidden;",
		"white-space: nowrap;"
	],
	".tr-percent-bar>div", [
		"position: relative;",
		"display: inline-block;",
		"height: 8px;",
		"vertical-align: middle;"
	],
	".tr-percent-bar>div>div ", [
		"position: absolute;",
		"height: 100%;"
	],
	".tr-percent-bar>span", [
		"display: inline-block;",
		"vertical-align: middle;",
		"box-sizing: border-box;",
		"padding-left: 4px;",
		"padding-right: 4px;",
		"overflow: hidden;",
		"max-width: 100%;"
	]
]);

/** to apply percent bar style into elem
 * @public
 * @param {Element} hostElem
 */
PercentBar.injectCss = function (hostElem) {
	Object(Util["a" /* injectCss */])(this._styles, hostElem);
};

/** @public
* @returns {Element}
*/
PercentBar.prototype.getElement = function () {
	return this._topNode;
};

/** @public
* @returns {number}
*/
PercentBar.prototype.getValue = function () {
	return this._absValue * this._sign;
};
/** @public
* @returns {number}
*/
PercentBar.prototype.getPercent = function () {
	return (this._absValue / this._maxValue) * this._sign;
};

/** @public
* @param {number} value
* @param {number=} opt_max
* @param {string=} opt_displayText
*/
PercentBar.prototype.setValue = function (value, opt_max, opt_displayText) {
	var t = this;
	if(!value && value !== 0) { // NaN or undefined
		t._absValue = NaN;
		if(!t._invalid) {
			t._invalid = true;
			t._topNode.style.display = "none";
		}
		return;
	} else {
		if(t._invalid) {
			t._invalid = false;
			t._topNode.style.display = "";
		}
	}
	if(value >= 0) {
		t._absValue = value;
		t._dirtySign |= t._sign !== 1;
		t._sign = 1;
	} else {
		t._absValue = -value;
		t._dirtySign |= t._sign !== -1;
		t._sign = -1;
	}

	if(opt_max != null) {
		t._maxValue = (opt_max >= 0) ? opt_max : -opt_max;
	}
	if(t._absValue > t._maxValue) {
		t._absValue = t._maxValue;
	}
	t._update(true, opt_displayText);
};
/** @public
* @param {number} absVal
*/
PercentBar.prototype.setMax = function (absVal) {
	this._maxValue = (absVal >= 0) ? absVal : -absVal;
	if(this._absValue > this._maxValue) {
		this._absValue = this._maxValue;
	}
	this._update();
};

/** @public
* @param {string} txt
*/
PercentBar.prototype.setText = function (txt) {
	if(!this._invalid) {
		if(this._txt._prevText !== txt) {
			this._txt._prevText = txt;
			this._txt.textContent = txt;
			if (this._tooltipEnabled) {
				if(txt) {
					this._topNode.setAttribute("title", txt);
				} else {
					this._topNode.removeAttribute("title");
				}
			}
		}
	}
};
/** @public
* @param {boolean=} opt_hiden
*/
PercentBar.prototype.hideText = function (opt_hiden) {
	this._textHidden = opt_hiden !== false;
	if(this._textHidden) {
		Dom.removeParent(this._txt);
	} else {
		this._reorderElements();
	}
	this.setAlignment(this._alignment);
};
/** @public
* @return {boolean}
*/
PercentBar.prototype.isTextHidden = function () {
	return this._textHidden || (this._textWidth === "0px");
};

/** Use when alignment is not center. This will be a reserved space for text
* @public
* @param {number|string} width
*/
PercentBar.prototype.setTextWidth = function (width) {
	if(typeof width === "number") {
		if(width <= 8) {
			console.log("Please use hideText() method instead of small textWidth");
			width = 0;
		}
		width = width + "px";
	} else if(!width) { // undefined, NaN, null, and ""
		width = "56px";
	}

	var txtWidth = width;
	if(this._textWidth !== txtWidth) {
		this._textWidth = txtWidth;
		this.setAlignment(this._alignment);
	}
};
/** @public
* @function
* @param {number|string} width
*/
PercentBar.prototype.setMaxTextLength = PercentBar.prototype.setTextWidth;
/** @public
* @return {number} scrollWidth
*/
PercentBar.prototype.getTextScrollWidth = function() {
	if(this._txt.scrollWidth > this._txt.offsetWidth) {
		return this._txt.scrollWidth;
	}
	return NaN;
};

/** @public
* @returns {string} alignment Alignment can be "left", "center", "right"
*/
PercentBar.prototype.getAlignment = function () {
	switch(this._alignment) {
	case "l": return "left";
	case "r": return "right";
	}
	return "center";
};

/** @public
* @param {string} alignment Alignment can be "left", "center", "right"
*/
PercentBar.prototype.setAlignment = function (alignment) {
	if(alignment) {
		alignment = alignment.charAt(0).toLowerCase();
	} else {
		alignment = "c";
	}

	if(alignment === "c") {
		this._track.style.width = "50%";
		this._txt.style.width = '50%';
		this._txt.style.textOverflow = 'elipsis';
		this._dirtySign = true;
	} else {
		if (this.isTextHidden()) {
			this._track.style.width = "100%";
		} else {
			this._track.style.width = "calc(100% - " + this._textWidth + ")";
		}
		this._txt.style.width = this._textWidth; // Text width can be percent ("50%") or pixel ("50px")
		this._txt.style.textAlign = "right";

		this._track.style.left = ""; // Important
		this._txt.style.transform = ""; // Important

		if(alignment === "r") {
			this._bar.style.right = "0";
		} else {
			this._bar.style.right = "";
		}
	}

	if(this._alignment !== alignment) {
		this._alignment = alignment;
		if(!this.isTextHidden()) {
			this._reorderElements();
		}
	}
	this._update(false);
};
/** @private */
PercentBar.prototype._reorderElements = function () {
	if(this._alignment !== "l") {
		this._topNode.appendChild(this._track);
		this._topNode.appendChild(this._txt);
	} else { // align left
		this._topNode.appendChild(this._txt);
		this._topNode.appendChild(this._track);
	}
};

/** @public
* @param {boolean=} opt_enabled
*/
PercentBar.prototype.useMovementColor = function (opt_enabled) {
	this._movementColorUsed = opt_enabled !== false;
	this.updateBarColor();
};

/** @public
* @param {string=} color
*/
PercentBar.prototype.setTrackColor = function (color) {
	this._track.style.backgroundColor = color ? color : "";
};

/** @public
* @param {boolean=} enabled
*/
PercentBar.prototype.enableTooltip = function (enabled) {
	this._tooltipEnabled = enabled !== false;
	if(!this._tooltipEnabled) {
		this._topNode.removeAttribute("title");
	}
};

/** @private
* @param {boolean=} opt_updateVal
* @param {string=} opt_displayText
*/
PercentBar.prototype._update = function (opt_updateVal, opt_displayText) {
	var t = this;
	if(t._dirtySign) {
		t._dirtySign = false;
		if(t._alignment === "c") {
			if(t._sign >= 0) {
				t._track.style.left = "50%";
				t._bar.style.right = "";
				t._txt.style.transform = "translateX(-100%)";
				t._txt.style.textAlign = "right";
			} else {
				t._track.style.left = "";
				t._bar.style.right = "0";
				t._txt.style.transform = "";
				t._txt.style.textAlign = "left";
			}
		}

		if(t._movementColorUsed) {
			t.updateBarColor();
		}
	}

	if (opt_updateVal !== false) {
		var percent = t._maxValue !== 100 ? t._absValue / t._maxValue * 100 : t._absValue;
		t._bar.style.width = percent + "%";
		if(opt_displayText != null) {
			t.setText(opt_displayText);
		} else {
			t.setText(((percent * t._sign * 100) | 0) / 100 + "%");
		}
	}
};
/** update percent bar color to current theme
* @public
*/
PercentBar.prototype.updateBarColor = function () {
	var trackColor = ElfUtil.themeColors["trackColor"];
	if(this._movementColorUsed) {
		trackColor = this._sign >= 0 ? ElfUtil.themeColors["up"] :  ElfUtil.themeColors["down"];
	}
	this._bar.style.backgroundColor = trackColor;
};

/* harmony default export */ var es6_PercentBar = (PercentBar);


// CONCATENATED MODULE: ./src/js/PercentBarFormatter.js



/** @typedef {Object} PercentBarFormatter~Options
* @description FormatterBuilder options
* @property {string=} alignment
* @property {boolean=} movementColor
* @property {boolean=} textHidden
* @property {(number|string)=} textWidth
*/

/** Due to stamping technique is used in the FormatterBuilder, we have to store the constructor in context object
* @private
* @param {Object} ctx Context object
* @param {Object} options User options
*/
var PercentBarFormatter_onContextCreated = function (ctx, options) {
	ctx.PercentBar = PercentBar;
};

/** @private
* @param {Element} element
* @param {Object} ctx Context object
*/
var PercentBarFormatter_onElementCreated = function (element, ctx) {
	var pb = new ctx.PercentBar(element);

	element["_percentBar"] = pb;
	if(ctx.alignment) {
		pb.setAlignment(ctx.alignment);
	}
	if(ctx.movementColor != null) {
		pb.useMovementColor(ctx.movementColor);
	}
	if(ctx.textHidden != null) {
		pb.hideText(ctx.textHidden);
	}
	if(ctx.textWidth) {
		pb.setTextWidth(ctx.textWidth);
	}
};

/** @private
* @param {Element} element
* @param {Object} ctx Context object
*/
var PercentBarFormatter_onElementUpdated = function (element, ctx) {
	element["_percentBar"].setValue(ctx.value);
};

/** @constructor
* @param {*=} options
*/
var PercentBarFormatter = function (options) {

};

/** @public
* @param {(FormatterBuilder.Options|PercentBarFormatter.Options|Object)=} options
* @return {Object}
*/
PercentBarFormatter.create = function (options) {
	var defaultOpt = {
		tagName: "div",
		refName: "PercentBarFormatter",
		onContextCreated: PercentBarFormatter_onContextCreated,
		onElementCreated: PercentBarFormatter_onElementCreated,
		onElementUpdated: PercentBarFormatter_onElementUpdated,
		alignment: 'l' //Default left alignment
	};

	return FormatterBuilder["a" /* default */].create(options, defaultOpt);
};

/* harmony default export */ var js_PercentBarFormatter = (PercentBarFormatter);


// CONCATENATED MODULE: ./src/js/SimpleImageFormatter.js


/** @typedef {Object} SimpleImageFormatter~Options
* @description FormatterBuilder options
* @property {(string|number)=} height
* @property {(string|number)=} width
*/

/** @private
* @function
* @param {Element} element
* @param {Object} ctx
*/
var SimpleImageFormatter_onElementUpdated = function (element, ctx) {
	element.src = ctx.value;
};

/** @constructor
* @param {*=} options
*/
var SimpleImageFormatter = function (options) {

};

/** @public
* @param {(FormatterBuilder.Options|SimpleImageFormatter.Options|Object)=} options
* @return {Object}
*/
SimpleImageFormatter.create = function (options) {
	var defaultOpt = {
		tagName: "img",
		refName: "SimpleImageFormatter",
		styles: {
			position: "absolute",
			maxHeight: "100%",
			top: 0,
			bottom: 0,
			left: 0,
			right: 0,
			margin: "auto"
		},
		onElementUpdated: SimpleImageFormatter_onElementUpdated,
		height: "auto",
		width: "auto"
	};

	defaultOpt.attributes = {
		height: defaultOpt.height,
		width: defaultOpt.width
	};
	if (options) {
		if (options.height != null) {
			defaultOpt.attributes.height = options.height;
		}
		if (options.width != null) {
			defaultOpt.attributes.width = options.width;
		}
	}

	return FormatterBuilder["a" /* default */].create(options, defaultOpt);
};

/* harmony default export */ var js_SimpleImageFormatter = (SimpleImageFormatter);


// CONCATENATED MODULE: ./src/js/SimpleInputFormatter.js


var SimpleInputFormatter_onElementUpdated = function (element, ctx) {
	element.value = ctx.value;
};

var SimpleInputFormatter_changeHandler = function (e, ctx) {
	ctx.value = e.currentTarget.value;
	ctx.setData(ctx.field, ctx.value);
};

/** @constructor
* @param {*=} options
*/
var SimpleInputFormatter = function (options) {

};

/** @public
* @param {(FormatterBuilder.Options|Object)=} options
* @return {Object}
*/
SimpleInputFormatter.create = function (options) {
	var defaultOpt = {
		tagName: "input",
		refName: "SimpleInputFormatter",
		onElementUpdated: SimpleInputFormatter_onElementUpdated,
		changeHook: "change",
		changeHandler: SimpleInputFormatter_changeHandler,
		styles: {
			margin: "0",
			width: "100%"
		}
	};

	return FormatterBuilder["a" /* default */].create(options, defaultOpt);
};

/* harmony default export */ var js_SimpleInputFormatter = (SimpleInputFormatter);


// CONCATENATED MODULE: ./src/js/SimpleLinkFormatter.js


/** @typedef {Object} SimpleLinkFormatter~Options
* @description FormatterBuilder options
* @property {string=} label
* @property {string=} urlField Field used for href attributed
*/

/** @private
* @param {Element} element
* @param {Object} ctx Context object
*/
var SimpleLinkFormatter_onElementUpdated = function (element, ctx) {
	var label = typeof ctx.label === "string" ? ctx.label : ctx.value;
	element.textContent = label;
	if(ctx.urlField) {
		element.setAttribute("href", ctx.getData(ctx.urlField));
	}
};

/** @constructor
* @param {*=} options
*/
var SimpleLinkFormatter = function (options) {

};

/** @public
* @param {(FormatterBuilder.Options|SimpleLinkFormatter.Options|Object)=} options
* @return {Object}
*/
SimpleLinkFormatter.create = function (options) {
	var defaultOpt = {
		tagName: "a",
		refName: "SimpleLinkFormatter",
		onElementUpdated: SimpleLinkFormatter_onElementUpdated,
		attributes: {
			class: 'text'
		},
		label: null,
		urlField: null
	};

	return FormatterBuilder["a" /* default */].create(options, defaultOpt);
};

/* harmony default export */ var js_SimpleLinkFormatter = (SimpleLinkFormatter);


// CONCATENATED MODULE: ./node_modules/tr-grid-util/es6/TickCodes.js
/** @type {Object.<string, number>}
* @public
*/
var TickCodes = {
	"\u21e7": 1,
	"B\u21e7": 1,
	"\u2191": 1,
	"B\u2191": 1,
	"26": 1,
	"1": 1,
	"\"1\"": 1,
	"-1": -1,
	"\u21e9": -1,
	"B\u21e9": -1,
	"\u2193": -1,
	"B\u2193": -1,
	"27": -1,
	"2": -1,
	"\"2\"": -1
};

/** @type {Object.<string, number>}
* @public
*/
var TickFields = {
	"CF_TICK": 1,
	"PRCTCK_1": 1,
	"BID_TICK": 1,
	"ASK_TICK": 1
};

/* harmony default export */ var es6_TickCodes = (TickCodes);


// CONCATENATED MODULE: ./src/js/SimpleTickerFormatter.js




/** @typedef {Object} SimpleTickerFormatter~Options
* @description FormatterBuilder options
* @property {string=} positiveColor Color code for up icon
* @property {string=} negativeColor Color code for down icon
*/

var SimpleTickerFormatter_onContextCreated = function (ctx, options) {
	if(es6_ElfUtil.getElfVersion() > 3) {
		ctx._upIcon = "arrow-up-fill";
		ctx._downIcon = "arrow-down-fill";
	} else {
		ctx._upIcon = "arrow-up";
		ctx._downIcon = "arrow-down";
	}
	ctx.TickCodes = es6_TickCodes;
};

var SimpleTickerFormatter_onElementUpdated = function (element, ctx) {
	var value = ctx.TickCodes[ctx.value];

	if (value === 1) {
		element.icon = ctx._upIcon;
		element.style.color = ctx.positiveColor;
	} else if (value === -1) {
		element.icon = ctx._downIcon;
		element.style.color = ctx.negativeColor;
	} else {
		element.icon = "";
	}
};

/** @constructor
* @param {*=} options
*/
var SimpleTickerFormatter = function (options) {

};

/** @public
* @param {(FormatterBuilder.Options|SimpleTickerFormatter~Options|Object)=} options
* @return {Object}
*/
SimpleTickerFormatter.create = function (options) {
	var defaultOpt = {
		tagName: "coral-icon",
		refName: "SimpleTickerFormatter",
		onContextCreated: SimpleTickerFormatter_onContextCreated,
		onElementUpdated: SimpleTickerFormatter_onElementUpdated,
		styles: {
			cursor: "default",
			verticalAlign: "middle"
		},
		positiveColor: "#39C46E",
		negativeColor: "#F5475B"
	};

	return FormatterBuilder["a" /* default */].create(options, defaultOpt);
};

/* harmony default export */ var js_SimpleTickerFormatter = (SimpleTickerFormatter);


// CONCATENATED MODULE: ./src/js/SimpleToggleFormatter.js



/** @typedef {Object} SimpleToggleFormatter~Options
* @description FormatterBuilder options
* @property {(string|Element)=} element1
* @property {(string|Element)=} element2
*/

/** @private
* @function
* @param {Node} n
* @return {Node}
*/
var _provideCloneMethod = function (n) {
	if (n && n.cloneNode) {
		return n;
	} else { // Workaround: custom element may not have cloneNode() method
		var span = document.createElement("span");
		if (n) {
			span.appendChild(n);
		}
		return span;
	}
};

/** @private
* @function
* @param {string=} icon
* @return {Element}
*/
var _createCoralButton = function (icon) {
	var btn = document.createElement("coral-button");
	var styles = "margin: 0;";
	if(es6_ElfUtil.getThemeName() === "elf-theme-halo") {
		styles += " min-width: 26px;";
	}
	btn.setAttribute("style", styles);
	if (icon) {
		btn.setAttribute("icon", icon);
	}
	return btn;
};

/** @private
* @function
* @param {*} n
* @return {Element}
*/
var _convertToElement = function (n) {
	if (n) {
		if (typeof n === "string") {
			var div = document.createElement("div");
			div.innerHTML = n.trim();
			return div.firstChild;
		}
		return n;
	}
	return null;
};

var SimpleToggleFormatter_onContextCreated = function (ctx, options) {
	ctx.element1 = _provideCloneMethod(ctx.element1);
	ctx.element2 = _provideCloneMethod(ctx.element2);
};

var SimpleToggleFormatter_onElementCreated = function (element, ctx) {
	element._element1 = ctx.element1.cloneNode(true);
	element._element2 = ctx.element2.cloneNode(true);
};

var SimpleToggleFormatter_onElementUpdated = function (element, ctx) {
	var prevChecked = element.firstChild ? element.firstChild === element._element1 : NaN;
	var checked = ctx.value;
	if (checked !== prevChecked) {
		if (element.firstChild) {
			element.removeChild(element.firstChild);
		}
		element.appendChild(checked ? element._element1 : element._element2);
	}
};

/** To uncheck and toggle data of the previous focus radio button
* @private
* @param {*} e
* @param {*} ctx
*/
var onClick = function (e, ctx) {
	var checked = ctx.getData(ctx.field);
	ctx.value = !checked;
	ctx.setData(ctx.field, ctx.value);
};

/** @constructor
* @param {*=} options
*/
var SimpleToggleFormatter = function (options) {

};

/** @public
* @param {(FormatterBuilder.Options|SimpleToggleFormatter.Options|Object)=} options
* @return {Object}
*/
SimpleToggleFormatter.create = function (options) {
	var defaultOpt = {
		tagName: "div",
		refName: "SimpleToggleFormatter",
		onContextCreated: SimpleToggleFormatter_onContextCreated,
		onElementCreated: SimpleToggleFormatter_onElementCreated,
		onElementUpdated: SimpleToggleFormatter_onElementUpdated,
		events: {
			"click": onClick
		},
		element1: _createCoralButton("tick"),
		element2: _createCoralButton()
	};

	if (options) {
		if (options.element1) {
			options.element1 = _convertToElement(options.element1);
		}
		if (options.element2) {
			options.element2 = _convertToElement(options.element2);
		}
	}

	return FormatterBuilder["a" /* default */].create(options, defaultOpt);
};

/* harmony default export */ var js_SimpleToggleFormatter = (SimpleToggleFormatter);


// CONCATENATED MODULE: ./src/js/TextFormatter.js



var TextFormatter_onElementUpdated = function (element, ctx) {
	element.textContent = ctx.value;
};

/** @constructor
* @param {*=} options
*/
var TextFormatter = function (options) {

};

/** @public
* @param {(FormatterBuilder.Options|Object)=} options
* @return {Object}
*/
TextFormatter.create = function (options) {
	var defaultOpt = {
		tagName: "div",
		refName: "TextFormatter",
		onElementUpdated: TextFormatter_onElementUpdated
	};

	return FormatterBuilder["a" /* default */].create(options, defaultOpt);
};

/* harmony default export */ var js_TextFormatter = (TextFormatter);


// CONCATENATED MODULE: ./src/index.js
/* eslint-disable */




















// tsd-disable
var tr = window["tr"];
if (!tr) {
	tr = window["tr"] = {};
}

tr.CoralButtonFormatter = js_CoralButtonFormatter;
tr.CoralCheckboxFormatter = js_CoralCheckboxFormatter;
tr.CoralComboBoxFormatter = js_CoralComboBoxFormatter;
tr.CoralIconFormatter = js_CoralIconFormatter;
tr.CoralInputFormatter = js_CoralInputFormatter;
tr.CoralRadioButtonFormatter = js_CoralRadioButtonFormatter;
tr.CoralSelectFormatter = js_CoralSelectFormatter;
tr.CoralToggleFormatter = js_CoralToggleFormatter;
tr.DuplexEmeraldDateTimePickerFormatter = js_DuplexEmeraldDateTimePickerFormatter;
tr.EmeraldDateTimePickerFormatter = js_EmeraldDateTimePickerFormatter;
tr.NumericInputFormatter = js_NumericInputFormatter;
tr.PercentBarFormatter = js_PercentBarFormatter;
tr.SimpleImageFormatter = js_SimpleImageFormatter;
tr.SimpleInputFormatter = js_SimpleInputFormatter;
tr.SimpleLinkFormatter = js_SimpleLinkFormatter;
tr.SimpleTickerFormatter = js_SimpleTickerFormatter;
tr.SimpleToggleFormatter = js_SimpleToggleFormatter;
tr.TextFormatter = js_TextFormatter;
// tsd-enable



/***/ })
/******/ ]);